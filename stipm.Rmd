---
title: "stipm"
author: "dan.auerbach@dfw.wa.gov modifying DeFilippo et al. 2021 in consultation with Thomas.Buehrens@dfw.wa.gov"
date: "`r Sys.Date()`"
editor_options: 
  chunk_output_type: console
output: 
  wdfwTemplates::wdfw_html_format

---

This script updates and extends the [original implementation](https://github.com/lukasdefilippo/ST-IPM) of [DeFilippo et al.'s (2021)](https://www.sciencedirect.com/science/article/pii/S0165783621001429) "Spatiotemporal Integrated Population Model" (ST-IPM) of Washington state natural origin coho (*O. kisutch*) returns, with initial application to annual preseason forecasts of Willapa Bay returning adults.

TODO

 - revisit extracting `_est` and/or `_pred`: 
  - current AR1 stan call runs through last_data_year+1, so 2018 dataset includes 2019 in `adult_est`
  - but current STIPM stan call ends `adult_est` in last_data_year, with y+1 in `adult_pred`?
 - how to get "2022" given postseason FRAM through 2019
 - revise/move "fit stan" section with one_ahead wrappers:
  - first do one-aheads to calc skill (still need to write perf measure funcs, but quick)
  - then do "full" series fits for "final" forecast(s)
 - revise one_ahead wrappers to provide less data?
 - confer with MB on backwards-vs-escapement mismatches


# setup

```{r setup, results = FALSE, warning = FALSE, message = FALSE}
knitr::opts_chunk$set(echo = TRUE, results = FALSE, warning = FALSE, message = FALSE)

library("tidyverse")
library("odbc"); library("DBI")
library("rstan")
options(mc.cores = 10) #12 on DA machine
rstan_options(auto_write = TRUE)
theme_set(theme_light())

f_orig <- "Coho_IPM_spatial_AR.r"

fp <- list(
  fram_mdb_pre2010 = "O:/code/coho_fram_validation/FramVS2-PSC-Coho-Backwards-thru2016 use me.mdb",
  fram_mdb_2010onward =  "O:/code/coho_fram_validation/PSC_CoTC_PostSeason_CohoFRAMDB_2010thru2019_021021.mdb",
  coho_file = 'Coho data_3-30-20.csv',
  cwt_file = 'CWT_FRAM_Matches_complete20200303.csv',
  stream_file = 'Coho_KM_3.31.2020_2.csv'
  )

#lu_stock <- readxl::read_excel("stipm_pops_crosscheck.xlsx")
#lu_stock |> filter(FRAM_StockID != 10, FRAM_StockID != 24) |> pluck("FRAM_StockID") |> paste0(collapse = ",")
#drop 13 and 43
fram_stocks <- c(105,93,89,45,51,55,75,81,61,23,149,63,107,115,111,157,97,135,153,101,69,1,85,139,131,127,145,11,17,59,35,29,117,161)

maybe_drop_popids <- c(
#these should probably go...
  10, #not sure what this actually is...
  24, #Pt Gamble, fixed BKFRAM input, not a pop
#these maybe...
  14, #Dungeness, recent estimate difficulties, but smolt ests
  16, #Elwha, recent method changes and special habitat case 
  18, #Green, relevance, recent estimate difficulties, but smolt ests
  21, #LkWA, relevance/pop size
  23 #Nooksack, proxy not an escp est, but smolt ests
  )

focal_popids <- c(36:33, 29, 26)
focal_popids <- 36

```

# data

The analysis relies on per-stock escapement and harvest estimates compiled in post-season [coho FRAM](https://github.com/FRAMverse/fram_doc) runs as well as CWT-based marine survival estimates derived from RMIS.

Here, the original data ingest and preparation flow has been condensed following line-wise deconstruction, reconstruction and object testing.

The resulting "full data" object forms the basis for subsequent model-fitting, prediction and evaluation.

```{r tbl_coho_full}
#presumably this will change further with a reduced/updated FRAM dataset
#for now preserving smoltCWT<-->FRAMunit assignment choices in original
#and largely preserving the order of operations (e.g., multiple filter())

drop_pop <- c("Queets", "Clearwater", 'Bell Creek', 'Johnson Creek', 'Jimmy Come Lately Creek',
              'Deep Creek', 'McDonald Creek', 'Siebert Creek', 'Salt Creek', 'Discovery Bay',
              'East Twin Creek', 'West Twin Creek', 'Northeast Hood Canal')

drop_cwt_surv <- c("Minter Crk H", "Baker H", "Satsop H") 

tbl_coho <- readr::read_csv(fp$coho_file) |> #1709x21
  mutate(
    pop = case_when(
      !is.na(`SaSI Population`) ~ `SaSI Population`,
      is.na(`SaSI Population`) & is.na(SubPopulation) ~ `Managment Unit (FRAM)`,
      is.na(`SaSI Population`) & !is.na(SubPopulation) ~ SubPopulation
    ),
    spwn = case_when(
      !is.na(`SaSI Population`) ~ `SASI Natural Origin Abundance`,
      is.na(`SaSI Population`) & is.na(SubPopulation) ~ `Age 3 Escapement (FRAM)`,
      is.na(`SaSI Population`) & !is.na(SubPopulation) ~ `SupPopulation Escapement`
    ),
    spwn = if_else(pop=="Discovery Bay", `SASI CompositeOrigin Abundance`, abs(spwn)) #corrects negative val for 2005 A12A Wild, orig L152
    ,
    hvst = spwn / (1/`Harvest (% FRAM)` - 1) 
  ) |> 
  filter( !(pop %in% drop_pop) ) |> 
  select(`Calendar Year`, `Smolt Abundance`, Latitude, Longitude, pop, spwn, hvst) |> 
  inner_join(
    readr::read_csv(fp$stream_file) |> 
      filter(Population != "", !is.na(Population)) |> #no NAs in the current csv, but left for now
      select(pop = Population, KM)
    ,
    by = "pop") |> 
  full_join(
    readr::read_csv(fp$cwt_file) |> 
      mutate(
        hat = if_else(stringr::str_detect(`Smolt Ocean Survival Population`, " H$"), 1, 0)
      ) |> 
      filter( !(`Smolt Ocean Survival Population` %in% drop_cwt_surv)) |> 
      select(pop = `Managment Unit (FRAM)`, `Calendar Year`, `Smolt Ocean Survival Population`, Fishery_Plus_Escapement, Release_No, hat)
    ,
    by = c("pop", "Calendar Year")) |> 
  filter(`Calendar Year` > 1985) |> 
  bind_rows(
    tibble(`Calendar Year` = 2013, yr = 28, pop = "Area 7-7A Independent Wild"),
    tibble(`Calendar Year` = 2004, yr = 19, pop = "Port Gamble Bay Wild"),
    tibble(`Calendar Year` = 2000:2001, yr = 15:16, pop = "Grays Harbor Miscellaneous Wild")
  ) |>
  left_join(
    bind_rows(
      tibble(pop = "Green River Wild", Long = -122.2145, Lat = 47.3519),
      tibble(pop = "Area 10E Miscellaneous Wild", Long = -122.8242, Lat = 47.5896)
    )
    , by = "pop") |>
  mutate(
    Longitude = if_else(is.na(Long), Longitude, Long), Long = NULL,
    Latitude = if_else(is.na(Lat), Latitude, Lat), Lat = NULL,
    Basin = if_else(Longitude < -123.80, 0, 1),
    `Smolt Abundance` = if_else(pop == "Puyallup River Wild", NA_real_, `Smolt Abundance`),
    hvst = if_else(stringr::str_detect(pop, "Quillayute River") & `Calendar Year` <= 1987, NA_real_, hvst),
    pop_id = as.numeric(factor(pop)),
    yr = `Calendar Year` - min(`Calendar Year`) + 1
  ) |> 
  rename(year = `Calendar Year`) |> 
  arrange(pop)

sf_coord <- tbl_coho |> 
  group_by(pop, pop_id) |> 
  summarise(long = median(Longitude, na.rm = T), lat = median(Latitude, na.rm = T), .groups = "drop") |> 
  sf::st_as_sf(coords = c("long", 'lat'), crs = sf::st_crs("+proj=longlat +datum=WGS84")) |> 
  sf::st_transform(crs = sf::st_crs("+proj=utm +zone=10T ellps=WGS84"))

```

Skipping recreation of `state_cast` data object of compiled prior forecasts.

## Cross-reference

Dump a file for discussion and review of included series.

```{r dataset_out}
# tbl_coho |> 
#   group_by(pop_id, pop) |> 
#   summarise(
#     year_min = min(`Calendar Year`),
#     year_max = max(`Calendar Year`),
#     nobs_any = n(),
#     across(c(spwn, hvst, `Smolt Abundance`, Release_No), ~sum(!is.na(.))),
#     .groups = "drop"
#   ) |> #print(n = 50)
#   ##writexl::write_xlsx("stipm_pops_crosscheck.xlsx")
```

Pull in recent BackwardsFRAM and Cohort tables

```{r read_bkfram_cohort}
#manually crossref'd to "fram_coho_escapement_2021_020121.xlsx"
#comparing 

db <- "O:/code/coho_fram_validation/PSC_CoTC_PostSeason_CohoFRAMDB_2010thru2019_021021.mdb"
db_con <- DBI::dbConnect(drv = odbc::odbc(),
  .connection_string = paste0("Driver={Microsoft Access Driver (*.mdb, *.accdb)};DBQ=",db,";"))
tbl(db_con, "RunID") |> select(RunID, RunYear, TAMMName) #34:43, 2010:2019
#no idea why RunID == 0 is in this database...
#or why 39/2015 has 246 (vs 93 to 95 in other runs/years)...maybe just 0s for all stocks
bkfram <- tbl(db_con, "BackwardsFRAM") |> 
  filter(between(RunID, 34, 43)) |> 
  select(RunID, StockID, escp = TargetEscAge3) |> 
  left_join(tbl(db_con, "RunID") |> select(RunID, RunYear, RunTitle, TAMMName), by = "RunID") |> 
  left_join(tbl(db_con, "Stock") |> filter(Species == "COHO") |> select(StockID, StockLongName), by = "StockID") |> 
  collect()

cohort <- tbl(db_con, "Cohort") |> 
  filter(between(RunID, 34, 43)) |> 
  select(-PrimaryKey) |> 
  left_join(tbl(db_con, "RunID") |> select(RunID, RunYear, RunTitle, TAMMName), by = "RunID") |> 
  left_join(tbl(db_con, "Stock") |> filter(Species == "COHO") |> select(StockID, StockLongName), by = "StockID") |> 
  collect()

DBI::dbDisconnect(db_con)
```

```{r crossref_bkfram_cohort}
# #not sure which, if any, of these are comparable...
# cohort |> #count(RunID, RunYear) |> 
#   select(RunYear, StockID, StockLongName, TimeStep, Cohort, StartCohort) |> 
#   filter(
#     str_detect(StockLongName, "Wild|Natural"),
#     StockID < 165, TimeStep == 1
#     )

bkfram |> #count(RunID, RunYear) |> 
  select(RunYear, StockID, StockLongName, escp) |> 
  filter(
    str_detect(StockLongName, "Wild|Natural"),
    !(RunYear == 2015 & escp == 0),
    StockID < 165,
    between(RunYear, 2016, 2017)
    ) |> 
  pivot_wider(names_from = RunYear, values_from = escp) |> 
  print(n = 100)

tbl_coho |> 
  select(year, pop, spwn) |> 
  filter(between(year, 2016, 2017)) |> 
  pivot_wider(names_from = year, values_from = spwn) |> 
  print(n = 40)

```

## alternative ingest from CoTC post-season databases

Coho FRAM tracks age 3 fish across 5 time steps corresponding to a calendar year. It includes unmarked and marked units of both natural and hatchery stocks. Prior to 1998, the marked and unmarked components in validation runs were each simply defined as 50% of the hatchery or wild values.

The current set of post-season runs is split across two Access file databases corresponding to pre-2010 and 2010-onward.

```{r fram_readers}
read_coho_backwards <- function (db, runs = NULL, stocks = NULL) {

  db_con <- DBI::dbConnect(drv = odbc::odbc(),
    .connection_string = paste0("Driver={Microsoft Access Driver (*.mdb, *.accdb)};DBQ=", db, ";"))

  #lazy, full table then reduce as specified
  bk <- dplyr::tbl(db_con, "BackwardsFRAM") |> dplyr::select(RunID, StockID, escp = TargetEscAge3)
  if (!is.null(runs)) { bk <- dplyr::filter(bk, RunID %in% runs) }
  if (!is.null(stocks)) { bk <- dplyr::filter(bk, StockID %in% stocks) }

  #associate metainfo and pull
  bk <- bk |> 
    dplyr::left_join(
      dplyr::tbl(db_con, "RunID") |>  dplyr::select(RunID, RunYear, RunName), 
      by = "RunID") |>
    dplyr::left_join(
      dplyr::tbl(db_con, "Stock") |> dplyr::filter(Species == "COHO") |> dplyr::select(StockID, StockLongName),
      by = "StockID") |>
    dplyr::collect() |> 
    dplyr::arrange(RunYear, StockID)

  DBI::dbDisconnect(db_con)
  
  return(bk)
}

read_coho_escapement <- function (db, runs = NULL, stocks = NULL) {

  db_con <- DBI::dbConnect(drv = odbc::odbc(),
    .connection_string = paste0("Driver={Microsoft Access Driver (*.mdb, *.accdb)};DBQ=", db, ";"))
  #coho is already only age 3 in TimeStep 5
  #lazy, full table then reduce as specified
  escp <- dplyr::tbl(db_con, "Escapement") |> dplyr::select(RunID, StockID, escp = Escapement)
  if (!is.null(runs)) { escp <- dplyr::filter(escp, RunID %in% runs) }
  if (!is.null(stocks)) { escp <- dplyr::filter(escp, StockID %in% stocks) }

  #associate metainfo and pull
  escp <- escp |> 
    dplyr::left_join(
      dplyr::tbl(db_con, "RunID") |>  dplyr::select(RunID, RunYear, RunName), 
      by = "RunID") |>
    dplyr::left_join(
      dplyr::tbl(db_con, "Stock") |> dplyr::filter(Species == "COHO") |> dplyr::select(StockID, StockLongName),
      by = "StockID") |>
    dplyr::collect() |> 
    dplyr::arrange(RunYear, StockID)

  DBI::dbDisconnect(db_con)
  
  return(escp)
}

read_coho_mort <- function (db, runs = NULL, stocks = NULL) {
  
  db_con <- DBI::dbConnect(drv = odbc::odbc(),
    .connection_string = paste0("Driver={Microsoft Access Driver (*.mdb, *.accdb)};DBQ=", db, ";"))
  
  #lazy, full table then reduce as specified
  m <- dplyr::tbl(db_con, "Mortality") |> dplyr::select(-PrimaryKey)
  if (!is.null(runs)) { m <- dplyr::filter(m, RunID %in% runs) }
  if (!is.null(stocks)) { m <- dplyr::filter(m, StockID %in% stocks) }

  #associate metainfo and pull
  m <- m |> 
    dplyr::left_join(
      dplyr::tbl(db_con, "RunID") |>  dplyr::select(RunID, RunYear, RunName), 
      by = "RunID") |>
    dplyr::left_join(
      dplyr::tbl(db_con, "Stock") |> dplyr::filter(Species == "COHO") |> dplyr::select(StockID, StockLongName),
      by = "StockID") |>
    dplyr::left_join(
      dplyr::tbl(db_con, "Fishery") |> dplyr::filter(Species == "COHO") |> dplyr::select(FisheryID, FisheryName), 
      by = "FisheryID") |> 
    dplyr::collect() |> 
    dplyr::arrange(RunYear, FisheryID, TimeStep, StockID)

  DBI::dbDisconnect(db_con)
  
  return(m)
}
```

```{r read_fram_tables}
fram <- list(
  bk = bind_rows(
    read_coho_backwards(fp$fram_mdb_pre2010, runs = c(2:22,25:28), stocks = fram_stocks) 
    ,
    read_coho_backwards(fp$fram_mdb_2010onward, runs = 34:43, stocks = fram_stocks)
  )
  ,
  escp = bind_rows(
    read_coho_escapement(fp$fram_mdb_pre2010, runs = c(2:22,25:28), stocks = fram_stocks) 
    ,
    read_coho_escapement(fp$fram_mdb_2010onward, runs = 34:43, stocks = fram_stocks)
  )
  ,
  m = bind_rows(
    read_coho_mort(fp$fram_mdb_pre2010, runs = c(2:22,25:28), stocks = fram_stocks)
    ,
    read_coho_mort(fp$fram_mdb_2010onward, runs = 34:43, stocks = fram_stocks)
  ) |>
    mutate(mort = LandedCatch + NonRetention + Shaker + DropOff + MSFLandedCatch + MSFNonRetention + MSFShaker + MSFDropOff) |> 
    group_by(RunYear, StockID, StockLongName) |> 
    summarise(mort = sum(mort), .groups = "drop")
)

#### Quick diagnostics

#through 1998
fram$bk |> #count(RunID, RunYear) |> 
  select(RunYear, StockID, StockLongName, escp) |> 
  # filter(
  #   !(RunYear == 2015 & escp == 0),
  #   between(RunYear, 2016, 2017)
  #   ) |> 
  pivot_wider(names_from = RunYear, values_from = escp) |> print(n = 100)

#back to 1985
fram$escp |> 
  select(RunYear, StockID, StockLongName, escp) |> 
  pivot_wider(names_from = RunYear, values_from = escp) |> print(n = 100)

#note also potential for negative values in FRAM-generated escapement
fram$escp |> filter(escp < 0)

#some meaningful differences do exist in some year-stocks, including recent
#values can be larger from either/both tables
#but mostly larger in BK
left_join(
  fram$bk |> select(RunYear, StockID, escp), 
  fram$escp |> select(RunYear, StockID, escp),
  by = c("RunYear", "StockID"),
  suffix = c("bk", "es")
  ) |> 
  mutate(d = escpbk - escpes) |> filter(abs(d) > 100) |> arrange(desc(d)) |> print(n = 100)

fram$m |> pivot_wider(names_from = RunYear, values_from = mort) |> print(n = 100)
  
```

# fit stan

Here we declare a few intermediates to reduce repeated filter calls around different data elements (reaching the vectors with no missing data required by stan).

```{r tbl_coho_stan}
#wrapper to incrementally (re)build stan-ready intermediary objects
tbl_coho_filter_to_stan <- function(full, year_min = 1986, year_max = 2018){
  full = full |> 
    filter(between(year, year_min, year_max)) |> 
    mutate(yr = year - min(year) + 1)
  list(
    smolt = filter(full, !is.na(`Smolt Abundance`)),
    esc = filter(full, !is.na(spwn)),
    #mutate overrides the single bad harvest val related to neg escapement/ER>1 issue above
    catch = filter(full, !is.na(hvst)) |> mutate(hvst = abs(hvst)),
    MS = filter(full, !is.na(Release_No)), #note both "Release_No" and "Fishery_Plus_Escapement" are used in orig, setting up potential divergence conflict
    rtrn = full |> mutate(rtrn = spwn + abs(hvst)) |> #same fix as catch
      filter(!is.na(rtrn))
  )
}

tbl_coho_stan <- tbl_coho_filter_to_stan(tbl_coho, year_min = 1986, year_max = 2018) #as original
```

## STIPM

```{r revised_stan_fit_stipm}
#dropping iter for testing but otherwise using original function default control args on L456-7
#actual fit on L1272 uses 20K iter and 5 chains but otherwise same

#would prefer better within-list naming convention, but for now left as-is other than reorg around data types
fit_stipm <- stan(
  file = 'LD_coho_forecast_6_2_4.stan', 
  iter = 200,
  chains = 4,
  control = list(
    adapt_delta = 0.99,
    max_treedepth = 10.25
    ),
  thin = 1,
  seed = 222,
  data = list(
    n_year = length(unique(tbl_coho$year)), #orig includes NA with 1986:2018
    n_pop = length(unique(tbl_coho$pop_id)), #orig includes 8 additional IDs for plotting 'Name' only (i.e., no data)
    u = matrix(1, nrow = 1, ncol = length(unique(tbl_coho$pop_id))),
    dist = units::drop_units(sf::st_distance(sf_coord)/10000), #values are identical
    #could also: as.matrix(dist(sf::st_coordinates(coord), 'euclidean', diag = TRUE, upper = TRUE)/10000)
    
    pop_smolt = unique(tbl_coho_stan$smolt$pop_id), #pop_ids with smolt data 
    n_pop_smolt = length(unique(tbl_coho_stan$smolt$pop_id)),
    smolt_true = tbl_coho_stan$smolt$yr,
    smolt_dat = tbl_coho_stan$smolt$`Smolt Abundance`,
    n_smolt = nrow(tbl_coho_stan$smolt),
    
    pop_esc = unique(tbl_coho_stan$esc$pop_id),  # pop_ids with escapement data
    n_pop_esc = length(unique(tbl_coho_stan$esc$pop_id)),
    esc_true = tbl_coho_stan$esc$yr,
    esc_dat = tbl_coho_stan$esc$spwn,
    n_esc = nrow(tbl_coho_stan$esc),
    
    pop_catch = unique(tbl_coho_stan$catch$pop_id), #pop_ids with harvest data
    n_pop_catch = length(unique(tbl_coho_stan$catch$pop_id)),
    harvest_true = tbl_coho_stan$catch$yr,
    harvest_dat = tbl_coho_stan$catch$hvst,
    n_harvest = nrow(tbl_coho_stan$catch),
    
    pop_MS = unique(tbl_coho_stan$MS$pop_id), #pop_ids with marine survival data
    n_pop_MS = length(unique(tbl_coho_stan$MS$pop_id)),
    MS_true = tbl_coho_stan$MS$yr, #orig uses Fishery_Plus_Escapement rather than Release_No to filter...
    MS_dat_x = tbl_coho_stan$MS$Fishery_Plus_Escapement |> round(), #stan expects integer...
    MS_dat_N = tbl_coho_stan$MS$Release_No,
    n_MS = nrow(tbl_coho_stan$MS),
    
    stream_dist = tbl_coho |> group_by(pop) |> summarise(d = mean(KM, na.rm = T), .groups = "drop") |> select(d) |> unlist() |> as.numeric(),
    
    #elements called "sigma_catch" and "sigma_smolt" are commented out
    #this is a passed arg in the orig exec_fun()
    sigma_esc = 0.2,
    
    n_hatchery = filter(tbl_coho, hat == 1) |> distinct(pop_id) |> nrow(),
    #NOT WHAT WE WANT: hatchery = filter(tbl_coho_stan$MS, hat == 1) |> distinct(pop_id) |> pluck("pop_id"),
    hatchery = distinct(tbl_coho_stan$MS, pop_id, pop, hat) |> 
      mutate(hat_id = if_else(hat > 0, row_number(), NA_integer_)) |> 
      filter(!is.na(hat_id)) |> pluck("hat_id"),
    wild = distinct(tbl_coho_stan$MS, pop_id, pop, hat) |> 
      mutate(hat_id = if_else(hat < 1, row_number(), NA_integer_)) |> 
      filter(!is.na(hat_id)) |> pluck("hat_id"), 
 
    slice_smolt_start = tbl_coho_stan$smolt |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
    slice_smolt_end = tbl_coho_stan$smolt |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
    
    slice_esc_start = tbl_coho_stan$esc |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
    slice_esc_end = tbl_coho_stan$esc |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
    
    slice_harvest_start = tbl_coho_stan$catch |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
    slice_harvest_end = tbl_coho_stan$catch |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
    
    slice_MS_start = tbl_coho_stan$MS |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
    slice_MS_end = tbl_coho_stan$MS |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid")
  )
)
```

## AR1

```{r stan_fit_ar1}
# #	only a few population-years missing estimates
# tbl_coho_stan$rtrn |> count(pop_id) |> print(n=50)
  
#why is n_year "+1" here?
#"_tot" refers to "total return"
# a "n_year_true_tot" gets declared but not passed and not expected by AR stan
fit_ar1 <- stan(
  file = 'LD_coho_forecast_AR_ind_2.stan',
  iter = 200,
  chains = 2,
  control = list(
    adapt_delta = 0.99,
    max_treedepth = 10.25
  ),
  thin = 1,
  seed = 222,
  data = list(
    #Number of years (total, includes several missing years for some stocks)
    n_year = length(unique(tbl_coho$year)) + 1,
    #Number of total populations    
    n_pop = length(unique(tbl_coho$pop_id)),
    #Number of populations with return data
    n_pop_tot = length(unique(tbl_coho_stan$rtrn$pop_id)),
    #Which populations possess return data
    pop_tot = unique(tbl_coho_stan$rtrn$pop_id),
    #Length of the return data vectors
    n_tot = nrow(tbl_coho_stan$rtrn), #length(tot_dat)
    #Vectors of all return data across all populations
    tot_dat = tbl_coho_stan$rtrn$rtrn,
    #Vectors of the indices identifying which years are those with non-NA data for the return data
    tot_true = tbl_coho_stan$rtrn$yr,
    #Paired vectors of slice points indicating the beginning, and end of the data for a particular population
    slice_tot_start = tbl_coho_stan$rtrn |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
    slice_tot_end = tbl_coho_stan$rtrn |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid")
    )
  )
```

## summarize fitted

Also, with current `tbl_coho_filter_to_stan` and `one_ahead` with `year_min` argument > min year in `tbl_coho` full dataset, the `yr` indexing is reset to `year_min`, hence the additional argument here.

```{r try_tidybayes, eval=FALSE}
#could further examine library(tidybayes)? and/or library(bayesplot)?
library(tidybayes)

fit_ar1 |> 
  recover_types(tbl_coho_stan$rtrn) |> #not doing much since pops already numerically indexed
  spread_draws(adult_est[y,i]) |> #TMI?
  median_qi()
```

```{r fit_smry}
#TB suggest appending "adult_pred" as the next year "forecast" in STIPM..?
#little wrapper to mod later, revise reliance on global `tbl_coho` for pop string lu
#only really need the "merged chains" output from summary() if continuing this route?

fit_smry <- function(
  fit_obj, 
  p = c(0.1, 0.5, 0.9),
  year_min = min(tbl_coho$year),
  lu = tbl_coho |> distinct(pop_id, pop)
  ) {
  x <- list(
    #adult_est is [year, pop] indexed
    adult_est = summary(fit_obj, pars = "adult_est", probs = p)$summary |> 
      as.data.frame() |> rownames_to_column("stan_out") |> tibble() |> 
      mutate(
        var = str_extract(stan_out, "[a-z]+[:punct:][a-z]+"),
        year = (year_min - 1) + as.numeric(str_extract(stan_out, "[0-9]{1,2}")),
        pop_id = str_remove(stan_out, var) |> str_split(",") |> map_dbl( ~str_extract(.x[2], "[0-9]+") |> as.numeric())
      ) |> 
      left_join(lu, by = "pop_id")
    ,
    #adult_pred is pop indexed only
    adult_pred = summary(fit_obj, pars = "adult_pred", probs = p)$summary |> 
      as.data.frame() |> rownames_to_column("stan_out") |> tibble() |> 
      mutate(
        var = str_extract(stan_out, "[a-z]+[:punct:][a-z]+"),
        pop_id = as.numeric(str_extract(stan_out, "[0-9]+"))
      ) |> 
      left_join(lu, by = "pop_id")
  )
  return(x)
}

fit_stipm_smry <- fit_smry(fit_stipm) #takes a few...
fit_ar1_smry <- fit_smry(fit_ar1)

fit_ar1_smry$adult_pred |> print(n = 100)
fit_ar1_smry$adult_est |> print(n = 100)
tail(fit_ar1_smry$adult_est)
tail(fit_ar1_smry$adult_pred) 
#true...
identical(
  fit_ar1_smry$adult_est |> filter(year == 2019) |> select(mean)
  ,
  fit_ar1_smry$adult_pred |> select(mean)
  )

#not true; no 2019
identical(
  fit_stipm_smry$adult_est |> filter(year == 2018) |> select(mean)
  ,
  fit_stipm_smry$adult_pred |> select(mean)
  )
identical(
  fit_stipm_smry$adult_est |> filter(year == 2017) |> select(mean)
  ,
  fit_stipm_smry$adult_pred |> select(mean)
  )

```

```{r playing_with_fit_ar1}
tbl_coho |> 
  #filter( !(pop_id %in% maybe_drop_popids)) |> 
  filter( pop_id %in% focal_popids) |> 
  select(year = year, pop_id, pop, spwn, hvst) |> 
  pivot_longer(c(spwn, hvst), names_to = "var", values_to = "val") |> 
  ggplot(aes(year, val, fill = var, color = var)) +
  geom_col(position = "stack") +
  geom_ribbon(
    aes(x = year, ymin = `10%`, ymax = `90%`), inherit.aes = F,
    data = fit_ar1_smry$adult_est |> 
      filter( pop_id %in% focal_popids) |> 
      select(year, pop_id, pop, var, `10%`, `90%`),
    alpha = 0.3, color = "gold", fill = "gold") +
  geom_line(
    data = fit_ar1_smry$adult_est |> 
      filter( pop_id %in% focal_popids) |> 
      select(year, pop_id, pop, var, val = `50%`)) +
  scale_fill_grey(aesthetics = c("fill", "color")) +
  scale_x_continuous(n.breaks = 12,  guide = guide_axis(n.dodge = 2)) +
  scale_y_continuous("Return", labels = scales::comma) +
  facet_wrap(~pop_id + pop, scales = "free", labeller = label_wrap_gen(multi_line = F), ncol = 1)

```

```{r toy_ribbons}
bind_rows(
  fit_ar1_smry$adult_est |> mutate(fit = "ar1")
  ,
  fit_stipm_smry$adult_est |> mutate(fit = "stipm")
  ) |> 
  filter(pop_id %in% focal_popids) |> 
  ggplot(aes(x = year, y = `50%`, ymin = `10%`, ymax = `90%`, color = fit, fill = fit)) +
  scale_y_continuous("Estimated adult return", labels = scales::comma) +
  wacolors::scale_fill_wa_d( aesthetics = c("fill", "color") ) +
  geom_ribbon(alpha = 0.5)
```


# one-ahead prediction

These chunks use a brute-force pattern of refitting stan to year-range-filtered lists of the relevant data.

Going forward, especially if including more than STIPM and AR1, can/should break out the (currently repeated in-map) dataset list creation so that only the actual stan call is getting mapped.

```{r demo_stretch_allpops}
library(slider)

#stretching: before = Inf, so cumulative
foo <- tbl_coho_stan$rtrn |> 
  #filter( pop_id %in% focal_popids) |> 
  select(year, pop_id, pop, rtrn) |>
  group_by(pop_id, pop) |> 
  mutate(
    rtrn_mu_cml = slide_dbl(rtrn, mean, .before = Inf),
    lm_fit = slide(
      .x = cur_data(), #the subset of rows
      .f = ~lm(rtrn ~ year, data = .x), #the thing to do to them
      .before = Inf, #how far back to look
      .complete = T
    ),
    lm_pred = lm_fit |> 
      map_dbl(~if_else(is.null(.x), NA_real_, last(.x$fitted.values)))
  ) |> 
  ungroup()

foo |> 
  select(-lm_fit) |> 
  filter(pop_id > 30) |> #reduce for plotting 
  pivot_longer(cols = -c(year, pop_id, pop), names_to = "var", values_to = "val") |> 
  {\(x) 
  ggplot(x, aes(year, val, color = var)) +
  geom_line(data = filter(x, var != "rtrn")) +
  geom_point(data = filter(x, var == "rtrn")) + 
  scale_x_continuous(n.breaks = 10,  guide = guide_axis(n.dodge = 2)) +
  facet_wrap(~pop_id, scales = "free", ncol = 1)
  }()
```

```{r one_ahead_controls}
#now fairly trivial to build list of stan data lists
one_ahead_year_min <- 2000
one_ahead_years_max <- 2015:2017

set_names(one_ahead_years_max) |> 
  map(~tbl_coho_filter_to_stan(full = tbl_coho, year_min = one_ahead_year_min, year_max = .x)) |> 
  map_df(
    ~.x |> #each yearmax list of stan datasets
      map(~.x |> #each stan dataset (smolt, esc, catch, MS, rtrn)
            summarise(
              n = n(), ymin = min(year), ymax = max(year),
              ymin = min(yr), ymax = max(yr))))
```

Assuming relatively little change to the population set, this `data = list()` still has substantial inefficiency in repeated wrangling calls. However these are very fast and preserve greatest flexibility to gain/lose pops across years.

Related: there are still a couple of calls to `tbl_coho` full dataset for elements that should not change over years, but we want to reconfirm these are appropriate in a one-ahead mode.

Need to confirm desired year lag in the data being fed: n, n-1, n-2, ...?

```{r one_ahead_stipm}
#various stan warnings get hidden within map

#this is very memory greedy - 3 years at 200iter/2chains is 150MB with Rstudio holding 1.3GB
#also ~5min/chain per year? something like 5-10m per year, again at 200/2

one_ahead_stipm <- set_names(one_ahead_years_max) |> 
  map(
    function(ymax){
      stan_data <- tbl_coho_filter_to_stan(full = tbl_coho, year_min = one_ahead_year_min, year_max = ymax)

      stan_fit <- stan(
        file = 'LD_coho_forecast_6_2_4.stan', 
        iter = 200, chains = 2, thin = 1, seed = 222,
        control = list(adapt_delta = 0.99, max_treedepth = 10.25),
        data = list(
          n_year = length(one_ahead_year_min:ymax), 
          n_pop = length(unique(tbl_coho$pop_id)),
          u = matrix(1, nrow = 1, ncol = length(unique(tbl_coho$pop_id))),
          dist = units::drop_units(sf::st_distance(sf_coord)/10000), #values are identical
          
          pop_smolt = unique(stan_data$smolt$pop_id), #pop_ids with smolt data 
          n_pop_smolt = length(unique(stan_data$smolt$pop_id)),
          smolt_true = stan_data$smolt$yr,
          smolt_dat = stan_data$smolt$`Smolt Abundance`,
          n_smolt = nrow(stan_data$smolt),
          
          pop_esc = unique(stan_data$esc$pop_id),  # pop_ids with escapement data
          n_pop_esc = length(unique(stan_data$esc$pop_id)),
          esc_true = stan_data$esc$yr,
          esc_dat = stan_data$esc$spwn,
          n_esc = nrow(stan_data$esc),
          
          pop_catch = unique(stan_data$catch$pop_id), #pop_ids with harvest data
          n_pop_catch = length(unique(stan_data$catch$pop_id)),
          harvest_true = stan_data$catch$yr,
          harvest_dat = stan_data$catch$hvst,
          n_harvest = nrow(stan_data$catch),
          
          pop_MS = unique(stan_data$MS$pop_id), #pop_ids with marine survival data
          n_pop_MS = length(unique(stan_data$MS$pop_id)),
          MS_true = stan_data$MS$yr, #orig uses Fishery_Plus_Escapement rather than Release_No to filter...
          MS_dat_x = stan_data$MS$Fishery_Plus_Escapement |> round(), #stan expects integer...
          MS_dat_N = stan_data$MS$Release_No,
          n_MS = nrow(stan_data$MS),
          
          stream_dist = tbl_coho |> group_by(pop) |> summarise(d = mean(KM, na.rm = T), .groups = "drop") |> select(d) |> unlist() |> as.numeric(),
          
          sigma_esc = 0.2,
          
          n_hatchery = filter(tbl_coho, hat == 1) |> distinct(pop_id) |> nrow(),
          hatchery = distinct(stan_data$MS, pop_id, pop, hat) |> 
            mutate(hat_id = if_else(hat > 0, row_number(), NA_integer_)) |> 
            filter(!is.na(hat_id)) |> pluck("hat_id"),
          wild = distinct(stan_data$MS, pop_id, pop, hat) |> 
            mutate(hat_id = if_else(hat < 1, row_number(), NA_integer_)) |> 
            filter(!is.na(hat_id)) |> pluck("hat_id"), 
          
          slice_smolt_start = stan_data$smolt |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
          slice_smolt_end = stan_data$smolt |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
          
          slice_esc_start = stan_data$esc |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
          slice_esc_end = stan_data$esc |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
          
          slice_harvest_start = stan_data$catch |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
          slice_harvest_end = stan_data$catch |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
          
          slice_MS_start = stan_data$MS |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
          slice_MS_end = stan_data$MS |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid")
        )
      )
      return(stan_fit)
    }
  )

str(one_ahead_stipm, max.level = 1)

```

```{r one_ahead_ar1}
#various stan warnings get hidden within map
one_ahead_ar1 <- set_names(one_ahead_years_max) |> 
  map(
    function(ymax){
      stan_data <- tbl_coho_filter_to_stan(full = tbl_coho, year_min = one_ahead_year_min, year_max = ymax)
      #return(stan_data)
      
      stan_fit <- stan(
        file = 'LD_coho_forecast_AR_ind_2.stan',
        iter = 200, chains = 2, thin = 1, seed = 222,
        control = list(adapt_delta = 0.99, max_treedepth = 10.25),
        data = list(
          #Number of years (total, includes several missing years for some stocks)
          n_year = length(one_ahead_year_min:ymax) + 1,
          #Number of total populations
          n_pop = length(unique(tbl_coho$pop_id)),
          #Number of populations with return data
          n_pop_tot = length(unique(stan_data$rtrn$pop_id)),
          #Which populations possess return data
          pop_tot = unique(stan_data$rtrn$pop_id),
          #Length of the return data vectors
          n_tot = nrow(stan_data$rtrn), #length(tot_dat)
          #Vectors of all return data across all populations
          tot_dat = stan_data$rtrn$rtrn,
          #Vectors of the indices identifying which years are those with non-NA data for the return data
          tot_true = stan_data$rtrn$yr,
          #Paired vectors of slice points indicating the beginning, and end of the data for a particular population
          slice_tot_start = stan_data$rtrn |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
          slice_tot_end = stan_data$rtrn |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid")
        )
      )
      return(stan_fit)
    }
  )

str(one_ahead_ar1, max.level = 1)

```


# compare skill

 - map summary function across one-ahead fits
 - join to observed
 - calc measures

```{r}
#currently ~10s per year...
#can/should reduce function to only adult_est?

one_ahead_stipm_smry <- map(.x = one_ahead_stipm, .f = fit_smry, year_min = one_ahead_year_min)

names(one_ahead_stipm_smry) |> 
  map_df(
    ~one_ahead_stipm_smry[[.x]]$adult_est |> 
      filter(pop_id == 36) |> 
      mutate(year_max = .x) |> 
      select(year_max, year, `10%`:`90%`, pop_id, pop) 
  ) |> 
  ggplot(aes(x = year, y = `50%`, ymin = `10%`, ymax = `90%`, color = year_max, fill = year_max)) +
  scale_y_continuous("Estimated adult return", labels = scales::comma) +
  scale_fill_brewer(type = "qual", aesthetics = c("fill", "color") ) +
  geom_ribbon(alpha = 0.2) + geom_line() +
  geom_point(
    data = tbl_coho_stan$esc |> filter(pop_id == 36, year >= one_ahead_year_min) |> select(year, spwn),
    aes(year, spwn),
    inherit.aes = F) +
  facet_wrap(~pop)



one_ahead_ar1_smry <- map(.x = one_ahead_ar1, .f = fit_smry, year_min = one_ahead_year_min)

names(one_ahead_ar1_smry) |> 
  map_df(
    ~one_ahead_ar1_smry[[.x]]$adult_est |> 
      filter(pop_id == 36) |> 
      mutate(year_max = .x) |> 
      select(year_max, year, `10%`:`90%`, pop_id, pop) 
  ) |> 
  ggplot(aes(x = year, y = `50%`, ymin = `10%`, ymax = `90%`, color = year_max, fill = year_max)) +
  scale_y_continuous("Estimated adult return", labels = scales::comma) +
  scale_fill_brewer(type = "qual", aesthetics = c("fill", "color") ) +
  geom_ribbon(alpha = 0.2) + geom_line() +
  geom_point(
    data = tbl_coho_stan$rtrn |> filter(pop_id == 36, year >= one_ahead_year_min) |> select(year, rtrn),
    aes(year, rtrn),
    inherit.aes = F) +
  facet_wrap(~pop)


#ar1 written so data through 2017 generates a 2018 in adult_est
one_ahead_ar1_smry$`2017`$adult_est |> tail()
#but stipm through 2017 ends adult_est with 2017
one_ahead_stipm_smry$`2017`$adult_est |> tail()
#and perhaps adds 2018 in adult_pred
one_ahead_stipm_smry$`2015`$adult_pred |> tail()

```

```{r}
#further into future just with larger n_year? oh yes.

fit_ar1_test <- stan(
  file = 'LD_coho_forecast_AR_ind_2.stan',
  iter = 200, chains = 2, thin = 1, seed = 222,
  control = list(adapt_delta = 0.99, max_treedepth = 10.25),
  data = list(
    #Number of years (total, includes several missing years for some stocks)
    n_year = length(unique(tbl_coho$year))*2,
    #Number of total populations    
    n_pop = length(unique(tbl_coho$pop_id)),
    #Number of populations with return data
    n_pop_tot = length(unique(tbl_coho_stan$rtrn$pop_id)),
    #Which populations possess return data
    pop_tot = unique(tbl_coho_stan$rtrn$pop_id),
    #Length of the return data vectors
    n_tot = nrow(tbl_coho_stan$rtrn), #length(tot_dat)
    #Vectors of all return data across all populations
    tot_dat = tbl_coho_stan$rtrn$rtrn,
    #Vectors of the indices identifying which years are those with non-NA data for the return data
    tot_true = tbl_coho_stan$rtrn$yr,
    #Paired vectors of slice points indicating the beginning, and end of the data for a particular population
    slice_tot_start = tbl_coho_stan$rtrn |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
    slice_tot_end = tbl_coho_stan$rtrn |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid")
    )
  )

fit_ar1_test_smry <- fit_smry(fit_ar1_test)

fit_ar1_test_smry$adult_est |> #tail() 
  filter(pop_id > 30) |> 
  ggplot(aes(x = year)) +
  scale_y_continuous("Estimated adult return", labels = scales::comma) +
  scale_fill_brewer(type = "qual", aesthetics = c("fill", "color") ) +
  geom_ribbon(aes(ymin = `10%`, ymax = `90%`), alpha = 0.2) + 
  geom_line(aes(y = `50%`)) +
  geom_point(
    data = tbl_coho_stan$rtrn |> filter(pop_id > 30) |> select(year, pop, pop_id, rtrn),
    aes(y = rtrn),
    inherit.aes = T) +
  facet_wrap(~pop)

```


# diagnostics and results



