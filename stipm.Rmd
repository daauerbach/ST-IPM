---
title: "stipm"
author: "dan.auerbach@dfw.wa.gov modifying DeFilippo et al. 2021 in consultation with Thomas.Buehrens@dfw.wa.gov"
date: "`r Sys.Date()`"
editor_options: 
  chunk_output_type: console
output: 
  wdfwTemplates::wdfw_html_format

---

This script updates and extends the [original implementation](https://github.com/lukasdefilippo/ST-IPM) of [DeFilippo et al.'s (2021)](https://www.sciencedirect.com/science/article/pii/S0165783621001429) "Spatiotemporal Integrated Population Model" (ST-IPM) of Washington state natural origin coho (*O. kisutch*) returns, with initial application to annual preseason forecasts of Willapa Bay returning adults.

TODO

 - revisit extracting `_est` and/or `_pred`: 
  - current AR1 stan call runs through last_data_year+1, so 2018 dataset includes 2019 in `adult_est`
  - but current STIPM stan call ends `adult_est` in last_data_year, with y+1 in `adult_pred`?
 - how to get "2022" given postseason FRAM through 2019
 - revise/move "fit stan" section with one_ahead wrappers:
  - first do one-aheads to calc skill (still need to write perf measure funcs, but quick)
  - then do "full" series fits for "final" forecast(s)
 - revise one_ahead wrappers to provide less data?
 - confer with MB on backwards-vs-escapement mismatches


# setup

```{r setup, results = FALSE, warning = FALSE, message = FALSE}
knitr::opts_chunk$set(echo = TRUE, results = FALSE, warning = FALSE, message = FALSE)

library("tidyverse")
library("odbc"); library("DBI")
library("rstan")
options(mc.cores = 10) #12 on DA machine
rstan_options(auto_write = TRUE)
theme_set(theme_light())

f_orig <- "Coho_IPM_spatial_AR.r"

fp <- list(
  fram_mdb_pre2010 = "O:/code/coho_fram_validation/FramVS2-PSC-Coho-Backwards-thru2016 use me.mdb",
  fram_mdb_2010onward =  "O:/code/coho_fram_validation/PSC_CoTC_PostSeason_CohoFRAMDB_2010thru2019_021021.mdb",
  coho_file = 'Coho data_3-30-20.csv',
  cwt_file = 'CWT_FRAM_Matches_complete20200303.csv',
  stream_file = 'Coho_KM_3.31.2020_2.csv'
  )

#lu_stock <- readxl::read_excel("stipm_pops_crosscheck.xlsx")
#lu_stock |> filter(FRAM_StockID != 13, FRAM_StockID != 43) |> pluck("FRAM_StockID") |> paste0(collapse = ",")
#drop FRAM StockID 13 and 43
fram_stocks <- c(105,93,89,45,51,55,75,81,61,23,149,63,107,115,111,157,97,135,153,101,69,1,85,139,131,127,145,11,17,59,35,29,117,161)

maybe_drop_popids <- c(
#these should probably go...
  10, #not sure what this actually is...
  24, #Pt Gamble, fixed BKFRAM input, not a pop
#these maybe...
  14, #Dungeness, recent estimate difficulties, but smolt ests
  16, #Elwha, recent method changes and special habitat case 
  18, #Green, relevance, recent estimate difficulties, but smolt ests
  21, #LkWA, relevance/pop size
  23 #Nooksack, proxy not an escp est, but smolt ests
  )

focal_popids <- c(36:33, 29, 26)
focal_popids <- 36

```

# data

The analysis relies on per-stock escapement and harvest estimates compiled in post-season [coho FRAM](https://github.com/FRAMverse/fram_doc) runs as well as CWT-based marine survival estimates derived from RMIS.

Here, the original data ingest and preparation flow has been condensed following line-wise deconstruction, reconstruction and object testing.

The resulting "full data" object forms the basis for subsequent model-fitting, prediction and evaluation.

```{r tbl_coho_full}
#presumably this will change further with a reduced/updated FRAM dataset
#for now preserving smoltCWT<-->FRAMunit assignment choices in original
#and largely preserving the order of operations (e.g., multiple filter())

drop_pop <- c("Queets", "Clearwater", 'Bell Creek', 'Johnson Creek', 'Jimmy Come Lately Creek',
              'Deep Creek', 'McDonald Creek', 'Siebert Creek', 'Salt Creek', 'Discovery Bay',
              'East Twin Creek', 'West Twin Creek', 'Northeast Hood Canal')

drop_cwt_surv <- c("Minter Crk H", "Baker H", "Satsop H") 

tbl_coho <- readr::read_csv(fp$coho_file) |> #1709x21
  mutate(
    pop = case_when(
      !is.na(`SaSI Population`) ~ `SaSI Population`,
      is.na(`SaSI Population`) & is.na(SubPopulation) ~ `Managment Unit (FRAM)`,
      is.na(`SaSI Population`) & !is.na(SubPopulation) ~ SubPopulation
    ),
    spwn = case_when(
      !is.na(`SaSI Population`) ~ `SASI Natural Origin Abundance`,
      is.na(`SaSI Population`) & is.na(SubPopulation) ~ `Age 3 Escapement (FRAM)`,
      is.na(`SaSI Population`) & !is.na(SubPopulation) ~ `SupPopulation Escapement`
    ),
    spwn = if_else(pop=="Discovery Bay", `SASI CompositeOrigin Abundance`, abs(spwn)) #corrects negative val for 2005 A12A Wild, orig L152
    ,
    hvst = spwn / (1/`Harvest (% FRAM)` - 1) 
  ) |> 
  filter( !(pop %in% drop_pop) ) |> 
  select(`Calendar Year`, `Smolt Abundance`, Latitude, Longitude, pop, spwn, hvst) |> 
  inner_join(
    readr::read_csv(fp$stream_file) |> 
      filter(Population != "", !is.na(Population)) |> #no NAs in the current csv, but left for now
      select(pop = Population, KM)
    ,
    by = "pop") |> 
  full_join(
    readr::read_csv(fp$cwt_file) |> 
      mutate(
        hat = if_else(stringr::str_detect(`Smolt Ocean Survival Population`, " H$"), 1, 0)
      ) |> 
      filter( !(`Smolt Ocean Survival Population` %in% drop_cwt_surv)) |> 
      select(pop = `Managment Unit (FRAM)`, `Calendar Year`, `Smolt Ocean Survival Population`, Fishery_Plus_Escapement, Release_No, hat)
    ,
    by = c("pop", "Calendar Year")) |> 
  filter(`Calendar Year` > 1985) |> 
  bind_rows(
    tibble(`Calendar Year` = 2013, yr = 28, pop = "Area 7-7A Independent Wild"),
    tibble(`Calendar Year` = 2004, yr = 19, pop = "Port Gamble Bay Wild"),
    tibble(`Calendar Year` = 2000:2001, yr = 15:16, pop = "Grays Harbor Miscellaneous Wild")
  ) |>
  left_join(
    bind_rows(
      tibble(pop = "Green River Wild", Long = -122.2145, Lat = 47.3519),
      tibble(pop = "Area 10E Miscellaneous Wild", Long = -122.8242, Lat = 47.5896)
    )
    , by = "pop") |>
  mutate(
    Longitude = if_else(is.na(Long), Longitude, Long), Long = NULL,
    Latitude = if_else(is.na(Lat), Latitude, Lat), Lat = NULL,
    Basin = if_else(Longitude < -123.80, 0, 1),
    `Smolt Abundance` = if_else(pop == "Puyallup River Wild", NA_real_, `Smolt Abundance`),
    hvst = if_else(stringr::str_detect(pop, "Quillayute River") & `Calendar Year` <= 1987, NA_real_, hvst),
    pop_id = as.numeric(factor(pop)),
    yr = `Calendar Year` - min(`Calendar Year`) + 1
  ) |> 
  rename(year = `Calendar Year`) |> 
  arrange(pop)

sf_coord <- tbl_coho |> 
  group_by(pop, pop_id) |> 
  summarise(long = median(Longitude, na.rm = T), lat = median(Latitude, na.rm = T), .groups = "drop") |> 
  sf::st_as_sf(coords = c("long", 'lat'), crs = sf::st_crs("+proj=longlat +datum=WGS84")) |> 
  sf::st_transform(crs = sf::st_crs("+proj=utm +zone=10T ellps=WGS84"))

```

Skipping recreation of `state_cast` data object of compiled prior forecasts.

## LU export

Dump a file for discussion and review of included series.

```{r stipm_pops}
# tbl_coho |> 
#   group_by(pop_id, pop) |> 
#   summarise(
#     year_min = min(`Calendar Year`),
#     year_max = max(`Calendar Year`),
#     nobs_any = n(),
#     across(c(spwn, hvst, `Smolt Abundance`, Release_No), ~sum(!is.na(.))),
#     .groups = "drop"
#   ) |> #print(n = 50)
#   ##writexl::write_xlsx("stipm_pops_crosscheck.xlsx")

# #4 cases of missing KM/Lat/Long due to the orig sequence of dataset construction
# #where a few additional records are added after joining stream lengths
# #but expect to drop 7/7A and Pt Gamble anyway
# #also following orig approach on "median" of Lat/Long, though already uniform 
# #manually copied into working xlsx, leaving pop_id/pops to confirm matches before deleting
# tbl_coho |> 
#   filter(!is.na(KM)) |>
#   group_by(pop_id, pop) |> 
#   summarise(across(c(Longitude, Latitude, KM), median), .groups = "drop") |> 
#   write.table("clipboard", row.names = F)

```

## Cross-check and updates

Alternative ingest from CoTC post-season databases. 

Could begin from pop metadata. Currently would 

```{r read_metadata}
#can convert to csv etc. as needed
readxl::read_excel("stipm_pops.xlsx")

```


Coho FRAM tracks age 3 fish across 5 time steps corresponding to a calendar year. It includes unmarked and marked units of both natural and hatchery stocks. Prior to 1998, the marked and unmarked components in validation runs were each simply defined as 50% of the hatchery or wild values.

The current set of post-season runs is split across two Access file databases corresponding to pre-2010 and 2010-onward.

```{r fram_readers}
read_coho_backwards <- function (db, runs = NULL, stocks = NULL) {

  db_con <- DBI::dbConnect(drv = odbc::odbc(),
    .connection_string = paste0("Driver={Microsoft Access Driver (*.mdb, *.accdb)};DBQ=", db, ";"))

  #lazy, full table then reduce as specified
  bk <- dplyr::tbl(db_con, "BackwardsFRAM") |> dplyr::select(RunID, StockID, escp = TargetEscAge3)
  if (!is.null(runs)) { bk <- dplyr::filter(bk, RunID %in% runs) }
  if (!is.null(stocks)) { bk <- dplyr::filter(bk, StockID %in% stocks) }

  #associate metainfo and pull
  bk <- bk |> 
    dplyr::left_join(
      dplyr::tbl(db_con, "RunID") |>  dplyr::select(RunID, RunYear, RunName), 
      by = "RunID") |>
    dplyr::left_join(
      dplyr::tbl(db_con, "Stock") |> dplyr::filter(Species == "COHO") |> dplyr::select(StockID, StockLongName),
      by = "StockID") |>
    dplyr::collect() |> 
    dplyr::arrange(RunYear, StockID)

  DBI::dbDisconnect(db_con)
  
  return(bk)
}

read_coho_escapement <- function (db, runs = NULL, stocks = NULL) {

  db_con <- DBI::dbConnect(drv = odbc::odbc(),
    .connection_string = paste0("Driver={Microsoft Access Driver (*.mdb, *.accdb)};DBQ=", db, ";"))
  #coho is already only age 3 in TimeStep 5
  #lazy, full table then reduce as specified
  escp <- dplyr::tbl(db_con, "Escapement") |> dplyr::select(RunID, StockID, escp = Escapement)
  if (!is.null(runs)) { escp <- dplyr::filter(escp, RunID %in% runs) }
  if (!is.null(stocks)) { escp <- dplyr::filter(escp, StockID %in% stocks) }

  #associate metainfo and pull
  escp <- escp |> 
    dplyr::left_join(
      dplyr::tbl(db_con, "RunID") |>  dplyr::select(RunID, RunYear, RunName), 
      by = "RunID") |>
    dplyr::left_join(
      dplyr::tbl(db_con, "Stock") |> dplyr::filter(Species == "COHO") |> dplyr::select(StockID, StockLongName),
      by = "StockID") |>
    dplyr::collect() |> 
    dplyr::arrange(RunYear, StockID)

  DBI::dbDisconnect(db_con)
  
  return(escp)
}

read_coho_mort <- function (db, runs = NULL, stocks = NULL) {
  
  db_con <- DBI::dbConnect(drv = odbc::odbc(),
    .connection_string = paste0("Driver={Microsoft Access Driver (*.mdb, *.accdb)};DBQ=", db, ";"))
  
  #lazy, full table then reduce as specified
  m <- dplyr::tbl(db_con, "Mortality") |> dplyr::select(-PrimaryKey)
  if (!is.null(runs)) { m <- dplyr::filter(m, RunID %in% runs) }
  if (!is.null(stocks)) { m <- dplyr::filter(m, StockID %in% stocks) }

  #associate metainfo and pull
  m <- m |> 
    dplyr::left_join(
      dplyr::tbl(db_con, "RunID") |>  dplyr::select(RunID, RunYear, RunName), 
      by = "RunID") |>
    dplyr::left_join(
      dplyr::tbl(db_con, "Stock") |> dplyr::filter(Species == "COHO") |> dplyr::select(StockID, StockLongName),
      by = "StockID") |>
    dplyr::left_join(
      dplyr::tbl(db_con, "Fishery") |> dplyr::filter(Species == "COHO") |> dplyr::select(FisheryID, FisheryName), 
      by = "FisheryID") |> 
    dplyr::collect() |> 
    dplyr::arrange(RunYear, FisheryID, TimeStep, StockID)

  DBI::dbDisconnect(db_con)
  
  return(m)
}
```

```{r read_fram_tables}
fram <- list(
  bk = bind_rows(
    read_coho_backwards(fp$fram_mdb_pre2010, runs = c(2:22,25:28), stocks = fram_stocks) 
    ,
    read_coho_backwards(fp$fram_mdb_2010onward, runs = 34:43, stocks = fram_stocks)
  )
  ,
  escp = bind_rows(
    read_coho_escapement(fp$fram_mdb_pre2010, runs = c(2:22,25:28), stocks = fram_stocks) 
    ,
    read_coho_escapement(fp$fram_mdb_2010onward, runs = 34:43, stocks = fram_stocks)
  )
  ,
  m = bind_rows(
    read_coho_mort(fp$fram_mdb_pre2010, runs = c(2:22,25:28), stocks = fram_stocks)
    ,
    read_coho_mort(fp$fram_mdb_2010onward, runs = 34:43, stocks = fram_stocks)
  ) |>
    mutate(mort = LandedCatch + NonRetention + Shaker + DropOff + MSFLandedCatch + MSFNonRetention + MSFShaker + MSFDropOff) |> 
    group_by(RunYear, StockID, StockLongName) |> 
    summarise(mort = sum(mort), .groups = "drop")
)
```

```{r xcheck_spwn}
#current dataset has 1986-2018 with a few NAs
tbl_coho |> 
  select(year, pop, spwn) |> 
#  filter(between(year, 2016, 2017)) |> 
  pivot_wider(names_from = year, values_from = spwn) |> 
  print(n = 40)

#BackwardsFRAM table has 1998-2019
fram$bk |> 
  #count(RunID, RunYear) |> print(n = 30)
  select(RunYear, StockID, StockLongName, escp) |> 
  # filter(
  #   !(RunYear == 2015 & escp == 0),
  #   between(RunYear, 2016, 2017)
  #   ) |> 
  pivot_wider(names_from = RunYear, values_from = escp) |> 
  print(n = 100)

#Escapement table has 1985-2019
#very likely the main source for orig dataset
#and/but is "post-FRAM" rather than directly received and has potential for negative
#see the -433 in 2005 for FRAMid 51/A12A wild
fram$escp |> filter(escp < 0)
fram$escp |> 
  select(RunYear, StockID, StockLongName, escp) |> 
  pivot_wider(names_from = RunYear, values_from = escp) |> print(n = 100)

#note the cbind doesn't imply diffs are calc'd from the same stock
#but that's actually useful to see if the stock ordering changes
#2016, many exact matches, larger diffs have larger escp in orig
#1998-99...basically perfect matches
#1986-1997 FRAM is 50% of orig (i.e. dataset using 2x FRAM val)
y <- 1997
fram$escp |> 
  select(RunYear, StockID, StockLongName, escp) |> 
  pivot_wider(names_from = RunYear, values_from = escp) |> 
  select(StockID, StockLongName, fram_yr = as.character(y)) |> 
  arrange(desc(fram_yr)) |> 
  bind_cols(
    tbl_coho |> select(year, pop_id, pop, spwn) |> 
      filter(pop_id != 10, pop_id != 24) |> 
      pivot_wider(names_from = year, values_from = spwn) |> 
      select(pop_id, pop, orig_yr = as.character(y)) |> 
      arrange(desc(orig_yr))
  ) |> 
  mutate(d_fram_orig = fram_yr - orig_yr) |> 
  print(n = 100)

# #Backwards vs Escapement
# #some meaningful differences do exist in some year-stocks, including recent
# #values can be larger from either/both tables
# #but mostly larger in BK
# left_join(
#   fram$bk |> select(RunYear, StockID, escp), 
#   fram$escp |> select(RunYear, StockID, escp),
#   by = c("RunYear", "StockID"),
#   suffix = c("bk", "es")
#   ) |> 
#   mutate(d = escpbk - escpes) |> 
#   filter(abs(d) > 100) |> arrange(desc(d)) |> print(n = 100)

```

```{r xcheck_hvst}
#2016, 1998 vals are very close, within range of calculation error
#1997 and older show the same doubling relative to FRAM, though not exact due to inversion calc
y <- 1986
fram$m |> 
  select(RunYear, StockID, StockLongName, mort) |> 
  pivot_wider(names_from = RunYear, values_from = mort) |> 
  select(StockID, StockLongName, fram_yr = as.character(y)) |> 
  arrange(desc(fram_yr)) |> 
  bind_cols(
    tbl_coho |> select(year, pop_id, pop, hvst) |> 
      filter(pop_id != 10, pop_id != 24) |> 
      pivot_wider(names_from = year, values_from = hvst) |> 
      select(pop_id, pop, orig_yr = as.character(y)) |> 
      arrange(desc(orig_yr))
  ) |> 
  mutate(d_fram_orig = fram_yr - orig_yr) |> 
  print(n = 100)

# #note WB naturals regularly one of the larger harvests according to FRAM
# fram$m |> 
#   select(RunYear, StockID, StockLongName, mort) |> 
#   ggplot(aes(RunYear, mort, fill = StockLongName)) +
#   geom_col(color = "grey") + scale_fill_discrete(guide = guide_legend(ncol = 1))

```

```{r viz_older_2x}
library("patchwork")

#what are these older year vals? FRAM archive guesses...?
#For WB, the first return year with escapement data in the regionally maintained run reconstruction file is 1996
#file "2021 WB4 Coho Forecast Model DRAFT 12.14.2020.xlsx", sheet RR
#1996: NOR escp+catch 15711+10992; tbl_coho is 16022 spwn, 11239 hvst; FRAM is 8011 escp, 5750 mort
#1997: NOR escp+catch 4934+1009; tbl_coho 5472+1530; FRAM is 2736+783
#1998: NOR escp+catch 13804+9200; tbl_coho 13806+10418; FRAM 13806+10579
#1999: NOR escp+catch 9628+1965; tbl_coho 12355+3319; FRAM 12355+3352
#2000: NOR escp+catch 23034+5003; tbl_coho 23032+7181; FRAM 23032+7345
{
  filter(tbl_coho, pop_id == 36, between(year, 1986, 2017)) |> 
    select(year, pop, spwn, hvst) |> pivot_longer(c(spwn, hvst), names_to = "var", values_to = "val") |> 
    mutate(var = factor(var, levels = c("spwn", "hvst"))) |> filter(year == 1999)
    ggplot(aes(as.character(year), val, fill = var)) + geom_col() +
    scale_x_discrete(guide = guide_axis(n.dodge = 2)) +
    scale_y_continuous("Willapa nat") +
    scale_fill_manual(values = c("spwn" = "darkgreen", "hvst" = "orange")) + labs(title = "Coho data_3-30-20.csv")
}+{
  inner_join(
    filter(fram$escp, StockID == 161) |> select(year = RunYear, StockID, pop = StockLongName, escp),
    filter(fram$m, StockID == 161) |> select(year = RunYear, StockID, pop = StockLongName, mort),
    by = c("year", "StockID", "pop")
  ) |>
    filter(between(year, 1986, 2017)) |> 
    pivot_longer(c(escp, mort), names_to = "var", values_to = "val") |> filter(year == 1999)
    ggplot(aes(year, val, fill = var)) + geom_col() + 
    scale_x_discrete(guide = guide_axis(n.dodge = 2)) +
    scale_y_continuous("Willapa nat") +
    scale_fill_manual(values = c("escp" = "darkgreen", "mort" = "orange")) + labs(title = "FRAM Escapement+Mortality tables")
}

```


# fit stan

## wrappers

```{r wrapper_stan_stipm}
stan_stipm <- function(full, year_min, year_max, n_iter = 200, n_chain = 2){
  #trim years
  full_ymin_ymax = filter(full, between(year, year_min, year_max)) |> 
    mutate(yr = year - min(year) + 1)
  
  #declare separate intermediaries
  stan_data = list(
      smolt = filter(full_ymin_ymax, !is.na(`Smolt Abundance`)),
      esc = filter(full_ymin_ymax, !is.na(spwn)),
      catch = filter(full_ymin_ymax, !is.na(hvst)) |> mutate(hvst = abs(hvst)),
      MS = filter(full_ymin_ymax, !is.na(Release_No)), #note both "Release_No" and "Fishery_Plus_Escapement" are used in orig, setting up potential divergence conflict
      rtrn = full_ymin_ymax |> 
        mutate(rtrn = spwn + abs(hvst)) |> #same fix as catch
        filter(!is.na(rtrn))
    )
    
  stan_fit <- stan(
    file = 'LD_coho_forecast_6_2_4.stan', 
    iter = n_iter, chains = n_chain, thin = 1, seed = 222,
    control = list(adapt_delta = 0.99, max_treedepth = 10.25),
    data = list(
      n_year = length(year_min:year_max), 
      n_pop = length(unique(stan_data$esc$pop_id)),
      u = matrix(1, nrow = 1, ncol = length(unique(stan_data$esc$pop_id))),
      dist = units::drop_units(sf::st_distance(sf_coord)/10000), #values are identical
      
      pop_smolt = unique(stan_data$smolt$pop_id), #pop_ids with smolt data 
      n_pop_smolt = length(unique(stan_data$smolt$pop_id)),
      smolt_true = stan_data$smolt$yr,
      smolt_dat = stan_data$smolt$`Smolt Abundance`,
      n_smolt = nrow(stan_data$smolt),
      
      pop_esc = unique(stan_data$esc$pop_id),  # pop_ids with escapement data
      n_pop_esc = length(unique(stan_data$esc$pop_id)),
      esc_true = stan_data$esc$yr,
      esc_dat = stan_data$esc$spwn,
      n_esc = nrow(stan_data$esc),
      
      pop_catch = unique(stan_data$catch$pop_id), #pop_ids with harvest data
      n_pop_catch = length(unique(stan_data$catch$pop_id)),
      harvest_true = stan_data$catch$yr,
      harvest_dat = stan_data$catch$hvst,
      n_harvest = nrow(stan_data$catch),
      
      pop_MS = unique(stan_data$MS$pop_id), #pop_ids with marine survival data
      n_pop_MS = length(unique(stan_data$MS$pop_id)),
      MS_true = stan_data$MS$yr, #orig uses Fishery_Plus_Escapement rather than Release_No to filter...
      MS_dat_x = stan_data$MS$Fishery_Plus_Escapement |> round(), #stan expects integer...
      MS_dat_N = stan_data$MS$Release_No,
      n_MS = nrow(stan_data$MS),
      
      stream_dist = stan_data$esc |> distinct(pop, KM) |> pluck("KM"), #previously taking mean, but values should be identical at this stage
      
      sigma_esc = 0.2,
      
      n_hatchery = filter(stan_data$MS, hat == 1) |> distinct(pop_id) |> nrow(),
      hatchery = distinct(stan_data$MS, pop_id, pop, hat) |> 
        mutate(hat_id = if_else(hat > 0, row_number(), NA_integer_)) |> 
        filter(!is.na(hat_id)) |> pluck("hat_id"),
      wild = distinct(stan_data$MS, pop_id, pop, hat) |> 
        mutate(hat_id = if_else(hat < 1, row_number(), NA_integer_)) |> 
        filter(!is.na(hat_id)) |> pluck("hat_id"), 
      
      slice_smolt_start = stan_data$smolt |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
      slice_smolt_end = stan_data$smolt |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
      
      slice_esc_start = stan_data$esc |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
      slice_esc_end = stan_data$esc |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
      
      slice_harvest_start = stan_data$catch |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
      slice_harvest_end = stan_data$catch |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
      
      slice_MS_start = stan_data$MS |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
      slice_MS_end = stan_data$MS |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid")
    )
  )
  return(stan_fit)
}

```

```{r wrapper_stan_ar1}
stan_ar1 <- function(full, year_min, year_max, n_iter = 200, n_chain = 2){
  #trim years
  full_ymin_ymax = filter(full, between(year, year_min, year_max)) |> 
    mutate(yr = year - min(year) + 1)
  
  #declare separate intermediaries
  #only actually need `rtrn` in AR1 context?
  stan_data = list(
      smolt = filter(full_ymin_ymax, !is.na(`Smolt Abundance`)),
      esc = filter(full_ymin_ymax, !is.na(spwn)),
      catch = filter(full_ymin_ymax, !is.na(hvst)) |> mutate(hvst = abs(hvst)),
      MS = filter(full_ymin_ymax, !is.na(Release_No)), #note both "Release_No" and "Fishery_Plus_Escapement" are used in orig, setting up potential divergence conflict
      rtrn = full_ymin_ymax |> 
        mutate(rtrn = spwn + abs(hvst)) |> #same fix as catch
        filter(!is.na(rtrn))
    )
    
  stan_fit <- stan(
    file = 'LD_coho_forecast_AR_ind_2.stan',
    iter = n_iter, chains = n_chain, thin = 1, seed = 222,
    control = list(adapt_delta = 0.99, max_treedepth = 10.25),
    data = list(
      #Number of years (total, includes several missing years for some stocks)
      n_year = length(year_min:year_max) + 1, 
      #Number of total populations    
      n_pop = length(unique(stan_data$rtrn$pop_id)),
      #Number of populations with return data
      n_pop_tot = length(unique(stan_data$rtrn$pop_id)),
      #Which populations possess return data
      pop_tot = unique(stan_data$rtrn$pop_id),
      #Length of the return data vectors
      n_tot = nrow(stan_data$rtrn), #length(tot_dat)
      #Vectors of all return data across all populations
      tot_dat = stan_data$rtrn$rtrn,
      #Vectors of the indices identifying which years are those with non-NA data for the return data
      tot_true = stan_data$rtrn$yr,
      #Paired vectors of slice points indicating the beginning, and end of the data for a particular population
      slice_tot_start = stan_data$rtrn |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
      slice_tot_end = stan_data$rtrn |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid")
    )
  )
  
  return(stan_fit)
}
```

With current filtering with `year_min` argument > min year in `tbl_coho` full dataset, the `yr` indexing is reset to `year_min`, hence the additional argument here.

```{r fit_smry_function}
#TB suggest appending "adult_pred" as the next year "forecast" in STIPM..?
#little wrapper to mod later, revise reliance on global `tbl_coho` for pop string lu
#only really need the "merged chains" output from summary() if continuing this route?

fit_smry <- function(
  fit_obj, 
  p = c(0.1, 0.5, 0.9),
  year_min = min(tbl_coho$year),
  lu = tbl_coho |> distinct(pop_id, pop)
  ) {
  x <- list(
    #adult_est is [year, pop] indexed
    adult_est = summary(fit_obj, pars = "adult_est", probs = p)$summary |> 
      as.data.frame() |> rownames_to_column("stan_out") |> tibble() |> 
      mutate(
        var = str_extract(stan_out, "[a-z]+[:punct:][a-z]+"),
        year = (year_min - 1) + as.numeric(str_extract(stan_out, "[0-9]{1,2}")),
        pop_id = str_remove(stan_out, var) |> str_split(",") |> map_dbl( ~str_extract(.x[2], "[0-9]+") |> as.numeric())
      ) |> 
      left_join(lu, by = "pop_id")
    ,
    #adult_pred is pop indexed only
    adult_pred = summary(fit_obj, pars = "adult_pred", probs = p)$summary |> 
      as.data.frame() |> rownames_to_column("stan_out") |> tibble() |> 
      mutate(
        var = str_extract(stan_out, "[a-z]+[:punct:][a-z]+"),
        pop_id = as.numeric(str_extract(stan_out, "[0-9]+"))
      ) |> 
      left_join(lu, by = "pop_id")
  )
  return(x)
}
```

## testing

```{r test_converge_start_1998}
## need to pull out PtGamble & 7/7A before pop_id assigned to avoid confusing stan indexing...
# tbl_coho <- filter(tbl_coho, !str_detect(pop, "Gamble|7-7A"))
# sf_coord <- filter(sf_coord, !str_detect(pop, "Gamble|7-7A")) 

Sys.time()
fit_stipm_86_17 <- stan_stipm(full = tbl_coho, year_min = 1986, year_max = 2017, n_iter = 2000, n_chain = 4)
fit_stipm_86_17_smry <- fit_smry(fit_stipm_86_17, year_min = 1986)
Sys.time()

fit_ar1_86_17 <- stan_ar1(full = tbl_coho, year_min = 1986, year_max = 2017)
fit_ar1_86_17_smry <- fit_smry(fit_ar1_86_17, year_min = 1986)

#currently incommensurate - AR1 returning spwn+hvst, STIPM just spwn...
bind_rows(
  fit_stipm_86_17_smry$adult_est |> mutate(fit = "stipm")
  ,
  fit_ar1_86_17_smry$adult_est |> mutate(fit = "ar1")
) |> 
  filter(pop_id == 36) |> 
  ggplot(aes(x = year, fill = fit, color = fit)) +
  scale_y_continuous("Estimated val", labels = scales::comma) +
  scale_fill_brewer(type = "qual", aesthetics = c("fill", "color") ) +
  geom_ribbon(aes(ymin = `10%`, ymax = `90%`), alpha = 0.2) + 
  geom_line(aes(y = `50%`)) +
  geom_point(
    data = tbl_coho |> mutate(fit = "obs") |> filter(pop_id == 36) |> select(fit, year, pop, pop_id, spwn),
    aes(y = spwn),
    inherit.aes = T) +
  facet_wrap(~pop)

Sys.time()
fit_stipm_98_17 <- stan_stipm(full = tbl_coho, year_min = 1998, year_max = 2017, n_iter = 2000, n_chain = 4)
fit_stipm_98_17_smry <- fit_smry(fit_stipm_98_17, year_min = 1998)
Sys.time()

fit_ar1_98_17 <- stan_ar1(full = tbl_coho, year_min = 1998, year_max = 2017)
fit_ar1_98_17_smry <- fit_smry(fit_ar1_98_17, year_min = 1998)

bind_rows(
  fit_ar1_86_17_smry$adult_est |> mutate(fit = "1986"),
  fit_ar1_98_17_smry$adult_est |> mutate(fit = "1998")
) |> 
  filter(pop_id == 36) |> 
  ggplot(aes(x = year, fill = fit, color = fit)) +
  scale_y_continuous("Estimated val", labels = scales::comma) +
  scale_fill_brewer(type = "qual", aesthetics = c("fill", "color") ) +
  geom_ribbon(aes(ymin = `10%`, ymax = `90%`), alpha = 0.2) + 
  geom_line(aes(y = `50%`)) +
  geom_point(
    data = tbl_coho |> mutate(fit = "obs", rtrn = spwn+hvst) |> filter(pop_id == 36) |> select(fit, year, pop, pop_id, rtrn),
    aes(y = rtrn),
    inherit.aes = T) +
  facet_wrap(~pop)


```

## stretch OAT

Moving ahead with brute-force pattern of refitting stan to year-range-filtered lists of the relevant data.

Could break out the pre-stan dataset list creation so that only the actual stan call is getting mapped. Assuming relatively little change to the population set, this `data = list()` still has substantial inefficiency in repeated wrangling calls. However these are very fast and preserve greatest flexibility to gain/lose pops across years.

Need to confirm desired year lag in the data being fed: n, n-1, n-2, ...?

Likely need 2 separate year_max args? First for final year of obs, second for final year desired for estimation

```{r revised_stretching_ar1}
oat_year_min <- 1998
oat_years_max <- 2009:2019

#want to do as a walk() or for() with in-loop dump outs?
#any way to reduce the memory claim? looks like AR1 is ~3-5min/yr for 1K4
Sys.time()
stretch_ar1 <- set_names(oat_years_max) |> 
  map(~stan_ar1(full = tbl_coho, year_min = oat_year_min, .x, n_iter = 1000, n_chain = 4))
Sys.time()

```



# Can delete soon

Here we declare a few intermediates to reduce repeated filter calls around different data elements (reaching the vectors with no missing data required by stan).

```{r tbl_coho_stan}
#wrapper to incrementally (re)build stan-ready intermediary objects
tbl_coho_filter_to_stan <- function(full, year_min = 1986, year_max = 2018){
  full = full |> 
    filter(between(year, year_min, year_max)) |> 
    mutate(yr = year - min(year) + 1)
  list(
    smolt = filter(full, !is.na(`Smolt Abundance`)),
    esc = filter(full, !is.na(spwn)),
    #mutate overrides the single bad harvest val related to neg escapement/ER>1 issue above
    catch = filter(full, !is.na(hvst)) |> mutate(hvst = abs(hvst)),
    MS = filter(full, !is.na(Release_No)), #note both "Release_No" and "Fishery_Plus_Escapement" are used in orig, setting up potential divergence conflict
    rtrn = full |> mutate(rtrn = spwn + abs(hvst)) |> #same fix as catch
      filter(!is.na(rtrn))
  )
}

tbl_coho_stan <- tbl_coho_filter_to_stan(tbl_coho, year_min = 1986, year_max = 2018) #as original
```

```{r revised_stan_fit_stipm}
# #dropping iter for testing but otherwise using original function default control args on L456-7
# #actual fit on L1272 uses 20K iter and 5 chains but otherwise same
# 
# #would prefer better within-list naming convention, but for now left as-is other than reorg around data types
# fit_stipm <- stan(
#   file = 'LD_coho_forecast_6_2_4.stan', 
#   iter = 200,
#   chains = 4,
#   control = list(
#     adapt_delta = 0.99,
#     max_treedepth = 10.25
#     ),
#   thin = 1,
#   seed = 222,
#   data = list(
#     n_year = length(unique(tbl_coho$year)), #orig includes NA with 1986:2018
#     n_pop = length(unique(tbl_coho$pop_id)), #orig includes 8 additional IDs for plotting 'Name' only (i.e., no data)
#     u = matrix(1, nrow = 1, ncol = length(unique(tbl_coho$pop_id))),
#     dist = units::drop_units(sf::st_distance(sf_coord)/10000), #values are identical
#     #could also: as.matrix(dist(sf::st_coordinates(coord), 'euclidean', diag = TRUE, upper = TRUE)/10000)
#     
#     pop_smolt = unique(tbl_coho_stan$smolt$pop_id), #pop_ids with smolt data 
#     n_pop_smolt = length(unique(tbl_coho_stan$smolt$pop_id)),
#     smolt_true = tbl_coho_stan$smolt$yr,
#     smolt_dat = tbl_coho_stan$smolt$`Smolt Abundance`,
#     n_smolt = nrow(tbl_coho_stan$smolt),
#     
#     pop_esc = unique(tbl_coho_stan$esc$pop_id),  # pop_ids with escapement data
#     n_pop_esc = length(unique(tbl_coho_stan$esc$pop_id)),
#     esc_true = tbl_coho_stan$esc$yr,
#     esc_dat = tbl_coho_stan$esc$spwn,
#     n_esc = nrow(tbl_coho_stan$esc),
#     
#     pop_catch = unique(tbl_coho_stan$catch$pop_id), #pop_ids with harvest data
#     n_pop_catch = length(unique(tbl_coho_stan$catch$pop_id)),
#     harvest_true = tbl_coho_stan$catch$yr,
#     harvest_dat = tbl_coho_stan$catch$hvst,
#     n_harvest = nrow(tbl_coho_stan$catch),
#     
#     pop_MS = unique(tbl_coho_stan$MS$pop_id), #pop_ids with marine survival data
#     n_pop_MS = length(unique(tbl_coho_stan$MS$pop_id)),
#     MS_true = tbl_coho_stan$MS$yr, #orig uses Fishery_Plus_Escapement rather than Release_No to filter...
#     MS_dat_x = tbl_coho_stan$MS$Fishery_Plus_Escapement |> round(), #stan expects integer...
#     MS_dat_N = tbl_coho_stan$MS$Release_No,
#     n_MS = nrow(tbl_coho_stan$MS),
#     
#     stream_dist = tbl_coho |> group_by(pop) |> summarise(d = mean(KM, na.rm = T), .groups = "drop") |> select(d) |> unlist() |> as.numeric(),
#     
#     #elements called "sigma_catch" and "sigma_smolt" are commented out
#     #this is a passed arg in the orig exec_fun()
#     sigma_esc = 0.2,
#     
#     n_hatchery = filter(tbl_coho, hat == 1) |> distinct(pop_id) |> nrow(),
#     #NOT WHAT WE WANT: hatchery = filter(tbl_coho_stan$MS, hat == 1) |> distinct(pop_id) |> pluck("pop_id"),
#     hatchery = distinct(tbl_coho_stan$MS, pop_id, pop, hat) |> 
#       mutate(hat_id = if_else(hat > 0, row_number(), NA_integer_)) |> 
#       filter(!is.na(hat_id)) |> pluck("hat_id"),
#     wild = distinct(tbl_coho_stan$MS, pop_id, pop, hat) |> 
#       mutate(hat_id = if_else(hat < 1, row_number(), NA_integer_)) |> 
#       filter(!is.na(hat_id)) |> pluck("hat_id"), 
#  
#     slice_smolt_start = tbl_coho_stan$smolt |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
#     slice_smolt_end = tbl_coho_stan$smolt |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
#     
#     slice_esc_start = tbl_coho_stan$esc |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
#     slice_esc_end = tbl_coho_stan$esc |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
#     
#     slice_harvest_start = tbl_coho_stan$catch |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
#     slice_harvest_end = tbl_coho_stan$catch |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
#     
#     slice_MS_start = tbl_coho_stan$MS |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
#     slice_MS_end = tbl_coho_stan$MS |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid")
#   )
# )

```

```{r stan_fit_ar1}
# # #	only a few population-years missing estimates
# # tbl_coho_stan$rtrn |> count(pop_id) |> print(n=50)
#   
# #why is n_year "+1" here?
# #"_tot" refers to "total return"
# # a "n_year_true_tot" gets declared but not passed and not expected by AR stan
# fit_ar1 <- stan(
#   file = 'LD_coho_forecast_AR_ind_2.stan',
#   iter = 200,
#   chains = 2,
#   control = list(
#     adapt_delta = 0.99,
#     max_treedepth = 10.25
#   ),
#   thin = 1,
#   seed = 222,
#   data = list(
#     #Number of years (total, includes several missing years for some stocks)
#     n_year = length(unique(tbl_coho$year)) + 1,
#     #Number of total populations    
#     n_pop = length(unique(tbl_coho$pop_id)),
#     #Number of populations with return data
#     n_pop_tot = length(unique(tbl_coho_stan$rtrn$pop_id)),
#     #Which populations possess return data
#     pop_tot = unique(tbl_coho_stan$rtrn$pop_id),
#     #Length of the return data vectors
#     n_tot = nrow(tbl_coho_stan$rtrn), #length(tot_dat)
#     #Vectors of all return data across all populations
#     tot_dat = tbl_coho_stan$rtrn$rtrn,
#     #Vectors of the indices identifying which years are those with non-NA data for the return data
#     tot_true = tbl_coho_stan$rtrn$yr,
#     #Paired vectors of slice points indicating the beginning, and end of the data for a particular population
#     slice_tot_start = tbl_coho_stan$rtrn |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
#     slice_tot_end = tbl_coho_stan$rtrn |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid")
#     )
#   )

```

```{r try_tidybayes, eval=FALSE}
#could further examine library(tidybayes)? and/or library(bayesplot)?
library(tidybayes)

fit_ar1 |> 
  recover_types(tbl_coho_stan$rtrn) |> #not doing much since pops already numerically indexed
  spread_draws(adult_est[y,i]) |> #TMI?
  median_qi()
```

```{r fit_smry_initial_testing}
fit_stipm_smry <- fit_smry(fit_stipm) #takes a few...
fit_ar1_smry <- fit_smry(fit_ar1)

fit_ar1_smry$adult_pred |> print(n = 100)
fit_ar1_smry$adult_est |> print(n = 100)
tail(fit_ar1_smry$adult_est)
tail(fit_ar1_smry$adult_pred) 
#true...
identical(
  fit_ar1_smry$adult_est |> filter(year == 2019) |> select(mean)
  ,
  fit_ar1_smry$adult_pred |> select(mean)
  )

#not true; no 2019
identical(
  fit_stipm_smry$adult_est |> filter(year == 2018) |> select(mean)
  ,
  fit_stipm_smry$adult_pred |> select(mean)
  )
identical(
  fit_stipm_smry$adult_est |> filter(year == 2017) |> select(mean)
  ,
  fit_stipm_smry$adult_pred |> select(mean)
  )

```

```{r playing_with_fit_ar1}
tbl_coho |> 
  #filter( !(pop_id %in% maybe_drop_popids)) |> 
  filter( pop_id %in% focal_popids) |> 
  select(year = year, pop_id, pop, spwn, hvst) |> 
  pivot_longer(c(spwn, hvst), names_to = "var", values_to = "val") |> 
  ggplot(aes(year, val, fill = var, color = var)) +
  geom_col(position = "stack") +
  geom_ribbon(
    aes(x = year, ymin = `10%`, ymax = `90%`), inherit.aes = F,
    data = fit_ar1_smry$adult_est |> 
      filter( pop_id %in% focal_popids) |> 
      select(year, pop_id, pop, var, `10%`, `90%`),
    alpha = 0.3, color = "gold", fill = "gold") +
  geom_line(
    data = fit_ar1_smry$adult_est |> 
      filter( pop_id %in% focal_popids) |> 
      select(year, pop_id, pop, var, val = `50%`)) +
  scale_fill_grey(aesthetics = c("fill", "color")) +
  scale_x_continuous(n.breaks = 12,  guide = guide_axis(n.dodge = 2)) +
  scale_y_continuous("Return", labels = scales::comma) +
  facet_wrap(~pop_id + pop, scales = "free", labeller = label_wrap_gen(multi_line = F), ncol = 1)

```

```{r toy_ribbons}
bind_rows(
  fit_ar1_smry$adult_est |> mutate(fit = "ar1")
  ,
  fit_stipm_smry$adult_est |> mutate(fit = "stipm")
  ) |> 
  filter(pop_id %in% focal_popids) |> 
  ggplot(aes(x = year, y = `50%`, ymin = `10%`, ymax = `90%`, color = fit, fill = fit)) +
  scale_y_continuous("Estimated adult return", labels = scales::comma) +
  wacolors::scale_fill_wa_d( aesthetics = c("fill", "color") ) +
  geom_ribbon(alpha = 0.5)
```


## one-ahead prediction

```{r demo_stretch_allpops}
library(slider)

#stretching: before = Inf, so cumulative
foo <- tbl_coho_stan$rtrn |> 
  #filter( pop_id %in% focal_popids) |> 
  select(year, pop_id, pop, rtrn) |>
  group_by(pop_id, pop) |> 
  mutate(
    rtrn_mu_cml = slide_dbl(rtrn, mean, .before = Inf),
    lm_fit = slide(
      .x = cur_data(), #the subset of rows
      .f = ~lm(rtrn ~ year, data = .x), #the thing to do to them
      .before = Inf, #how far back to look
      .complete = T
    ),
    lm_pred = lm_fit |> 
      map_dbl(~if_else(is.null(.x), NA_real_, last(.x$fitted.values)))
  ) |> 
  ungroup()

foo |> 
  select(-lm_fit) |> 
  filter(pop_id > 30) |> #reduce for plotting 
  pivot_longer(cols = -c(year, pop_id, pop), names_to = "var", values_to = "val") |> 
  {\(x) 
  ggplot(x, aes(year, val, color = var)) +
  geom_line(data = filter(x, var != "rtrn")) +
  geom_point(data = filter(x, var == "rtrn")) + 
  scale_x_continuous(n.breaks = 10,  guide = guide_axis(n.dodge = 2)) +
  facet_wrap(~pop_id, scales = "free", ncol = 1)
  }()
```

```{r one_ahead_controls}
#now fairly trivial to build list of stan data lists
one_ahead_year_min <- 1998
one_ahead_years_max <- 2015:2017

set_names(one_ahead_years_max) |> 
  map(~tbl_coho_filter_to_stan(full = tbl_coho, year_min = one_ahead_year_min, year_max = .x)) |> 
  map_df(
    ~.x |> #each yearmax list of stan datasets
      map(~.x |> #each stan dataset (smolt, esc, catch, MS, rtrn)
            summarise(
              n = n(), ymin = min(year), ymax = max(year),
              ymin = min(yr), ymax = max(yr))))
```

```{r one_ahead_stipm}
#various stan warnings get hidden within map

#this is very memory greedy - 3 years at 200iter/2chains is 150MB with Rstudio holding 1.3GB
#also ~5min/chain per year? something like 5-10m per year, again at 200/2

one_ahead_stipm <- set_names(one_ahead_years_max) |> 
  map(
    function(ymax){
      stan_data <- tbl_coho_filter_to_stan(full = tbl_coho, year_min = one_ahead_year_min, year_max = ymax)

      stan_fit <- stan(
        file = 'LD_coho_forecast_6_2_4.stan', 
        iter = 200, chains = 2, thin = 1, seed = 222,
        control = list(adapt_delta = 0.99, max_treedepth = 10.25),
        data = list(
          n_year = length(one_ahead_year_min:ymax), 
          n_pop = length(unique(tbl_coho$pop_id)),
          u = matrix(1, nrow = 1, ncol = length(unique(tbl_coho$pop_id))),
          dist = units::drop_units(sf::st_distance(sf_coord)/10000), #values are identical
          
          pop_smolt = unique(stan_data$smolt$pop_id), #pop_ids with smolt data 
          n_pop_smolt = length(unique(stan_data$smolt$pop_id)),
          smolt_true = stan_data$smolt$yr,
          smolt_dat = stan_data$smolt$`Smolt Abundance`,
          n_smolt = nrow(stan_data$smolt),
          
          pop_esc = unique(stan_data$esc$pop_id),  # pop_ids with escapement data
          n_pop_esc = length(unique(stan_data$esc$pop_id)),
          esc_true = stan_data$esc$yr,
          esc_dat = stan_data$esc$spwn,
          n_esc = nrow(stan_data$esc),
          
          pop_catch = unique(stan_data$catch$pop_id), #pop_ids with harvest data
          n_pop_catch = length(unique(stan_data$catch$pop_id)),
          harvest_true = stan_data$catch$yr,
          harvest_dat = stan_data$catch$hvst,
          n_harvest = nrow(stan_data$catch),
          
          pop_MS = unique(stan_data$MS$pop_id), #pop_ids with marine survival data
          n_pop_MS = length(unique(stan_data$MS$pop_id)),
          MS_true = stan_data$MS$yr, #orig uses Fishery_Plus_Escapement rather than Release_No to filter...
          MS_dat_x = stan_data$MS$Fishery_Plus_Escapement |> round(), #stan expects integer...
          MS_dat_N = stan_data$MS$Release_No,
          n_MS = nrow(stan_data$MS),
          
          stream_dist = tbl_coho |> group_by(pop) |> summarise(d = mean(KM, na.rm = T), .groups = "drop") |> select(d) |> unlist() |> as.numeric(),
          
          sigma_esc = 0.2,
          
          n_hatchery = filter(tbl_coho, hat == 1) |> distinct(pop_id) |> nrow(),
          hatchery = distinct(stan_data$MS, pop_id, pop, hat) |> 
            mutate(hat_id = if_else(hat > 0, row_number(), NA_integer_)) |> 
            filter(!is.na(hat_id)) |> pluck("hat_id"),
          wild = distinct(stan_data$MS, pop_id, pop, hat) |> 
            mutate(hat_id = if_else(hat < 1, row_number(), NA_integer_)) |> 
            filter(!is.na(hat_id)) |> pluck("hat_id"), 
          
          slice_smolt_start = stan_data$smolt |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
          slice_smolt_end = stan_data$smolt |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
          
          slice_esc_start = stan_data$esc |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
          slice_esc_end = stan_data$esc |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
          
          slice_harvest_start = stan_data$catch |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
          slice_harvest_end = stan_data$catch |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
          
          slice_MS_start = stan_data$MS |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
          slice_MS_end = stan_data$MS |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid")
        )
      )
      return(stan_fit)
    }
  )

str(one_ahead_stipm, max.level = 1)

```

```{r one_ahead_ar1}
#various stan warnings get hidden within map
one_ahead_ar1 <- set_names(one_ahead_years_max) |> 
  map(
    function(ymax){
      stan_data <- tbl_coho_filter_to_stan(full = tbl_coho, year_min = one_ahead_year_min, year_max = ymax)
      #return(stan_data)
      
      stan_fit <- stan(
        file = 'LD_coho_forecast_AR_ind_2.stan',
        iter = 200, chains = 2, thin = 1, seed = 222,
        control = list(adapt_delta = 0.99, max_treedepth = 10.25),
        data = list(
          #Number of years (total, includes several missing years for some stocks)
          n_year = length(one_ahead_year_min:ymax) + 1,
          #Number of total populations
          n_pop = length(unique(tbl_coho$pop_id)),
          #Number of populations with return data
          n_pop_tot = length(unique(stan_data$rtrn$pop_id)),
          #Which populations possess return data
          pop_tot = unique(stan_data$rtrn$pop_id),
          #Length of the return data vectors
          n_tot = nrow(stan_data$rtrn), #length(tot_dat)
          #Vectors of all return data across all populations
          tot_dat = stan_data$rtrn$rtrn,
          #Vectors of the indices identifying which years are those with non-NA data for the return data
          tot_true = stan_data$rtrn$yr,
          #Paired vectors of slice points indicating the beginning, and end of the data for a particular population
          slice_tot_start = stan_data$rtrn |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
          slice_tot_end = stan_data$rtrn |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid")
        )
      )
      return(stan_fit)
    }
  )

str(one_ahead_ar1, max.level = 1)

```

```{r first_look_repeat_fits}
#currently ~10s per year...
#can/should reduce function to only adult_est?

one_ahead_stipm_smry <- map(.x = one_ahead_stipm, .f = fit_smry, year_min = one_ahead_year_min)

names(one_ahead_stipm_smry) |> 
  map_df(
    ~one_ahead_stipm_smry[[.x]]$adult_est |> 
      filter(pop_id == 36) |> 
      mutate(year_max = .x) |> 
      select(year_max, year, `10%`:`90%`, pop_id, pop) 
  ) |> 
  ggplot(aes(x = year, y = `50%`, ymin = `10%`, ymax = `90%`, color = year_max, fill = year_max)) +
  scale_y_continuous("Estimated adult return", labels = scales::comma) +
  scale_fill_brewer(type = "qual", aesthetics = c("fill", "color") ) +
  geom_ribbon(alpha = 0.2) + geom_line() +
  geom_point(
    data = tbl_coho_stan$esc |> filter(pop_id == 36, year >= one_ahead_year_min) |> select(year, spwn),
    aes(year, spwn),
    inherit.aes = F) +
  facet_wrap(~pop)



one_ahead_ar1_smry <- map(.x = one_ahead_ar1, .f = fit_smry, year_min = one_ahead_year_min)

names(one_ahead_ar1_smry) |> 
  map_df(
    ~one_ahead_ar1_smry[[.x]]$adult_est |> 
      filter(pop_id == 36) |> 
      mutate(year_max = .x) |> 
      select(year_max, year, `10%`:`90%`, pop_id, pop) 
  ) |> 
  ggplot(aes(x = year, y = `50%`, ymin = `10%`, ymax = `90%`, color = year_max, fill = year_max)) +
  scale_y_continuous("Estimated adult return", labels = scales::comma) +
  scale_fill_brewer(type = "qual", aesthetics = c("fill", "color") ) +
  geom_ribbon(alpha = 0.2) + geom_line() +
  geom_point(
    data = tbl_coho_stan$rtrn |> filter(pop_id == 36, year >= one_ahead_year_min) |> select(year, rtrn),
    aes(year, rtrn),
    inherit.aes = F) +
  facet_wrap(~pop)


#ar1 written so data through 2017 generates a 2018 in adult_est
one_ahead_ar1_smry$`2017`$adult_est |> tail()
#but stipm through 2017 ends adult_est with 2017
one_ahead_stipm_smry$`2017`$adult_est |> tail()
#and perhaps adds 2018 in adult_pred
one_ahead_stipm_smry$`2015`$adult_pred |> tail()

```

```{r test_2050s}
#further into future just with larger n_year? oh yes.

fit_ar1_test <- stan(
  file = 'LD_coho_forecast_AR_ind_2.stan',
  iter = 200, chains = 2, thin = 1, seed = 222,
  control = list(adapt_delta = 0.99, max_treedepth = 10.25),
  data = list(
    #Number of years (total, includes several missing years for some stocks)
    n_year = length(unique(tbl_coho$year))*2,
    #Number of total populations    
    n_pop = length(unique(tbl_coho$pop_id)),
    #Number of populations with return data
    n_pop_tot = length(unique(tbl_coho_stan$rtrn$pop_id)),
    #Which populations possess return data
    pop_tot = unique(tbl_coho_stan$rtrn$pop_id),
    #Length of the return data vectors
    n_tot = nrow(tbl_coho_stan$rtrn), #length(tot_dat)
    #Vectors of all return data across all populations
    tot_dat = tbl_coho_stan$rtrn$rtrn,
    #Vectors of the indices identifying which years are those with non-NA data for the return data
    tot_true = tbl_coho_stan$rtrn$yr,
    #Paired vectors of slice points indicating the beginning, and end of the data for a particular population
    slice_tot_start = tbl_coho_stan$rtrn |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
    slice_tot_end = tbl_coho_stan$rtrn |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid")
    )
  )

fit_ar1_test_smry <- fit_smry(fit_ar1_test)

fit_ar1_test_smry$adult_est |> #tail() 
  filter(pop_id > 30) |> 
  ggplot(aes(x = year)) +
  scale_y_continuous("Estimated adult return", labels = scales::comma) +
  scale_fill_brewer(type = "qual", aesthetics = c("fill", "color") ) +
  geom_ribbon(aes(ymin = `10%`, ymax = `90%`), alpha = 0.2) + 
  geom_line(aes(y = `50%`)) +
  geom_point(
    data = tbl_coho_stan$rtrn |> filter(pop_id > 30) |> select(year, pop, pop_id, rtrn),
    aes(y = rtrn),
    inherit.aes = T) +
  facet_wrap(~pop)

```

# diagnostics and results


