---
title: "stipm"
author: "dan.auerbach@dfw.wa.gov modifying DeFilippo et al. 2021 in consultation with Thomas.Buehrens@dfw.wa.gov"
date: "`r Sys.Date()`"
editor_options: 
  chunk_output_type: console
output: 
  wdfwTemplates::wdfw_html_format

---

This script updates and extends the [original implementation](https://github.com/lukasdefilippo/ST-IPM) of [DeFilippo et al.'s (2021)](https://www.sciencedirect.com/science/article/pii/S0165783621001429) "Spatiotemporal Integrated Population Model" (ST-IPM) of Washington state natural origin coho (*O. kisutch*) returns, with initial application to annual preseason forecasts of Willapa Bay returning adults.

# setup

```{r setup, results = FALSE, warning = FALSE, message = FALSE}
knitr::opts_chunk$set(echo = TRUE, results = FALSE, warning = FALSE, message = FALSE)

library("tidyverse")
library("rstan")
options(mc.cores = 10) #12 on DA machine
rstan_options(auto_write = TRUE)

f_orig <- "Coho_IPM_spatial_AR.r"

#will reorg and rename these as needed
fp <- list(
  coho_file = 'Coho data_3-30-20.csv',
  cwt_file = 'CWT_FRAM_Matches_complete20200303.csv',
  stream_file = 'Coho_KM_3.31.2020_2.csv'
  )

```

# data

The analysis relies on per-stock escapement and harvest estimates compiled in post-season [coho FRAM](https://github.com/FRAMverse/fram_doc) runs as well as CWT-based marine survival estimates derived from RMIS.

Here, the original data ingest and preparation flow has been condensed following line-wise deconstruction, reconstruction and object testing.

The resulting "full data" object forms the basis for subsequent model-fitting, prediction and evaluation.

```{r tbl_coho_full}
#presumably this will change further with a reduced/updated FRAM dataset
#for now preserving smoltCWT<-->FRAMunit assignment choices in original
#and largely preserving the order of operations (e.g., multiple filter())

drop_pop <- c("Queets", "Clearwater", 'Bell Creek', 'Johnson Creek', 'Jimmy Come Lately Creek',
              'Deep Creek', 'McDonald Creek', 'Siebert Creek', 'Salt Creek', 'Discovery Bay',
              'East Twin Creek', 'West Twin Creek', 'Northeast Hood Canal')

drop_cwt_surv <- c("Minter Crk H", "Baker H", "Satsop H") 

tbl_coho <- readr::read_csv(fp$coho_file) |> #1709x21
  mutate(
    pop = case_when(
      !is.na(`SaSI Population`) ~ `SaSI Population`,
      is.na(`SaSI Population`) & is.na(SubPopulation) ~ `Managment Unit (FRAM)`,
      is.na(`SaSI Population`) & !is.na(SubPopulation) ~ SubPopulation
    ),
    spwn = case_when(
      !is.na(`SaSI Population`) ~ `SASI Natural Origin Abundance`,
      is.na(`SaSI Population`) & is.na(SubPopulation) ~ `Age 3 Escapement (FRAM)`,
      is.na(`SaSI Population`) & !is.na(SubPopulation) ~ `SupPopulation Escapement`
    ),
    spwn = if_else(pop=="Discovery Bay", `SASI CompositeOrigin Abundance`, abs(spwn)) #corrects negative val for 2005 A12A Wild, orig L152
    ,
    hvst = spwn / (1/`Harvest (% FRAM)` - 1) 
  ) |> 
  filter( !(pop %in% drop_pop) ) |> 
  select(`Calendar Year`, `Smolt Abundance`, Latitude, Longitude, pop, spwn, hvst) |> 
  inner_join(
    readr::read_csv(fp$stream_file) |> 
      filter(Population != "", !is.na(Population)) |> #no NAs in the current csv, but left for now
      select(pop = Population, KM)
    ,
    by = "pop") |> 
  full_join(
    readr::read_csv(fp$cwt_file) |> 
      mutate(
        hat = if_else(stringr::str_detect(`Smolt Ocean Survival Population`, " H$"), 1, 0)
      ) |> 
      filter( !(`Smolt Ocean Survival Population` %in% drop_cwt_surv)) |> 
      select(pop = `Managment Unit (FRAM)`, `Calendar Year`, `Smolt Ocean Survival Population`, Fishery_Plus_Escapement, Release_No, hat)
    ,
    by = c("pop", "Calendar Year")) |> 
  filter(`Calendar Year` > 1985) |> 
  bind_rows(
    tibble(`Calendar Year` = 2013, yr = 28, pop = "Area 7-7A Independent Wild"),
    tibble(`Calendar Year` = 2004, yr = 19, pop = "Port Gamble Bay Wild"),
    tibble(`Calendar Year` = 2000:2001, yr = 15:16, pop = "Grays Harbor Miscellaneous Wild")
  ) |>
  left_join(
    bind_rows(
      tibble(pop = "Green River Wild", Long = -122.2145, Lat = 47.3519),
      tibble(pop = "Area 10E Miscellaneous Wild", Long = -122.8242, Lat = 47.5896)
    )
    , by = "pop") |>
  mutate(
    Longitude = if_else(is.na(Long), Longitude, Long), Long = NULL,
    Latitude = if_else(is.na(Lat), Latitude, Lat), Lat = NULL,
    Basin = if_else(Longitude < -123.80, 0, 1),
    `Smolt Abundance` = if_else(pop == "Puyallup River Wild", NA_real_, `Smolt Abundance`),
    hvst = if_else(stringr::str_detect(pop, "Quillayute River") & `Calendar Year` <= 1987, NA_real_, hvst),
    pop_id = as.numeric(factor(pop)),
    yr = `Calendar Year` - min(`Calendar Year`) + 1
  ) |> 
  arrange(pop)

sf_coord <- tbl_coho |> 
  group_by(pop, pop_id) |> 
  summarise(long = median(Longitude, na.rm = T), lat = median(Latitude, na.rm = T), .groups = "drop") |> 
  sf::st_as_sf(coords = c("long", 'lat'), crs = sf::st_crs("+proj=longlat +datum=WGS84")) |> 
  sf::st_transform(crs = sf::st_crs("+proj=utm +zone=10T ellps=WGS84"))

```

Skipping recreation of `state_cast` data object of compiled prior forecasts.

## Cross-reference

Dump a file for discussion and review of included series.

```{r dataset_out}
# tbl_coho |> 
#   group_by(pop_id, pop) |> 
#   summarise(
#     year_min = min(`Calendar Year`),
#     year_max = max(`Calendar Year`),
#     nobs_any = n(),
#     across(c(spwn, hvst, `Smolt Abundance`, Release_No), ~sum(!is.na(.))),
#     .groups = "drop"
#   ) |> #print(n = 50)
#   ##writexl::write_xlsx("stipm_pops_crosscheck.xlsx")
```

Pull in the most recent BackwardsFRAM and Cohort tables

```{r read_bkfram_cohort}
#manually crossref'd to "fram_coho_escapement_2021_020121.xlsx"
#comparing 

db <- "O:/code/coho_fram_validation/PSC_CoTC_PostSeason_CohoFRAMDB_2010thru2019_021021.mdb"
db_con <- DBI::dbConnect(drv = odbc::odbc(),
  .connection_string = paste0("Driver={Microsoft Access Driver (*.mdb, *.accdb)};DBQ=",db,";"))
tbl(db_con, "RunID") |> select(RunID, RunYear, TAMMName) #34:43, 2010:2019
#no idea why RunID == 0 is in this database...
#or why 39/2015 has 246 (vs 93 to 95 in other runs/years)...maybe just 0s for all stocks
bkfram <- tbl(db_con, "BackwardsFRAM") |> 
  filter(between(RunID, 34, 43)) |> 
  select(RunID, StockID, escp = TargetEscAge3) |> 
  left_join(tbl(db_con, "RunID") |> select(RunID, RunYear, RunTitle, TAMMName), by = "RunID") |> 
  left_join(tbl(db_con, "Stock") |> filter(Species == "COHO") |> select(StockID, StockLongName), by = "StockID") |> 
  collect()

cohort <- tbl(db_con, "Cohort") |> 
  filter(between(RunID, 34, 43)) |> 
  select(-PrimaryKey) |> 
  left_join(tbl(db_con, "RunID") |> select(RunID, RunYear, RunTitle, TAMMName), by = "RunID") |> 
  left_join(tbl(db_con, "Stock") |> filter(Species == "COHO") |> select(StockID, StockLongName), by = "StockID") |> 
  collect()

DBI::dbDisconnect(db_con)
```

```{r bkfram_cohort}
# #not sure which, if any, of these are comparable...
# cohort |> #count(RunID, RunYear) |> 
#   select(RunYear, StockID, StockLongName, TimeStep, Cohort, StartCohort) |> 
#   filter(
#     str_detect(StockLongName, "Wild|Natural"),
#     StockID < 165, TimeStep == 1
#     )

bkfram |> #count(RunID, RunYear) |> 
  select(RunYear, StockID, StockLongName, escp) |> 
  filter(
    str_detect(StockLongName, "Wild|Natural"),
    !(RunYear == 2015 & escp == 0),
    StockID < 165,
    between(RunYear, 2016, 2017)
    ) |> 
  pivot_wider(names_from = RunYear, values_from = escp) |> 
  print(n = 100)

tbl_coho |> 
  select(`Calendar Year`, pop, spwn) |> 
  filter(between(`Calendar Year`, 2016, 2017)) |> 
  pivot_wider(names_from = `Calendar Year`, values_from = spwn) |> 
  print(n = 40)

```

# fit stan

## original STIPM

Further wrangling in `exec_fun()` targets the data list to pass to `stan()`.

```{r orig_pre_stan_wrangling}
#Create vector of basin identifiers for coastal and puget sound populations
basin <- aggregate(coho_dat_full$Basin, by=list('Population'=coho_dat_full$pop), mean, na.rm=TRUE)
coast <- basin$Population[basin$x==0]
sound <- basin$Population[basin$x==1]  

#Compute number of populations
n_pop <- length(unique(coho_dat_full$Population))

#Compute populations with smolt data
pop_smolt <- unique(coho_dat_full$pop[which(is.na(coho_dat_full$Smolt.Abundance)==FALSE)])
#Compute populations with marine survival data
pop_MS <- unique(coho_dat_full$pop[which(is.na(coho_dat_full$Release_No)==FALSE)])
#Compute populations with harvest data
pop_catch <- unique(coho_dat_full$pop[which(is.na(coho_dat_full$Harvest)==FALSE)])
#Compute populations with escapement data
pop_esc <- unique(coho_dat_full$pop[which(is.na(coho_dat_full$Spawners)==FALSE)])

#Compute number of populations with each data type available
n_pop_smolt <- length(pop_smolt)
n_pop_MS <- length(pop_MS)
n_pop_catch <- length(pop_catch)
n_pop_esc <- length(pop_esc)

#create vectors to store the number of years of smolt and escapement data available for each population being considered
n_year_true_smolt <- vector(length=n_pop_smolt)
n_year_true_esc <- vector(length=n_pop_esc)
n_year_true_harvest <- vector(length=n_pop_catch)
n_year_true_MS <- vector(length=n_pop_MS)

#Calculate the number of years for which each data type is available for each population
#Smolt data
for (i in 1:n_pop_smolt){
  n_year_true_smolt[i] <- length(na.omit(coho_dat_full$Smolt.Abundance[coho_dat_full$pop==pop_smolt[i]]))
}
#escapement data
for (i in 1:n_pop_esc){
  n_year_true_esc[i] <- length(na.omit(coho_dat_full$Spawners[coho_dat_full$pop==pop_esc[i]]))
}
#harvest data
for (i in 1:n_pop_catch){
  n_year_true_harvest[i] <- length(na.omit(coho_dat_full$Harvest[coho_dat_full$pop==pop_catch[i]]))
}
#marine survival data
for (i in 1:n_pop_MS){
  n_year_true_MS[i] <- length(na.omit(coho_dat_full$Fishery_Plus_Escapement[coho_dat_full$pop==pop_MS[i]]))
}

#Compile all the years across populations for which there is escapement and smolt data (not NAs)
esc_true <- coho_dat_full$yr[which(is.na(coho_dat_full$Spawners)==FALSE)]
smolt_true <- coho_dat_full$yr[which(is.na(coho_dat_full$Smolt.Abundance)==FALSE)]
harvest_true <- coho_dat_full$yr[which(is.na(coho_dat_full$Harvest )==FALSE)]
MS_true <- coho_dat_full$yr[which(is.na(coho_dat_full$Fishery_Plus_Escapement)==FALSE)]

#Compile all the actual observations of smolt and escapement data that are not NA
smolt_dat <- coho_dat_full$Smolt.Abundance[which(is.na(coho_dat_full$Smolt.Abundance)==FALSE)]                 
esc_dat <- coho_dat_full$Spawners[which(is.na(coho_dat_full$Spawners)==FALSE)]  
harvest_dat <- coho_dat_full$Harvest[which(is.na(coho_dat_full$Harvest )==FALSE)]      
MS_dat_x <- coho_dat_full$Fishery_Plus_Escapement[which(is.na(coho_dat_full$Fishery_Plus_Escapement)==FALSE)]      
MS_dat_N <- coho_dat_full$Release_No [which(is.na(coho_dat_full$Release_No)==FALSE)]      

#Create slice points for cutting up the intact (non-NA) smolt and escapement data by population (stan does not accept ragged data structures)
slice_smolt_start <- vector(length=n_pop_smolt)
slice_smolt_start[1] <- 1
slice_smolt_end <- vector(length=n_pop_smolt)
slice_smolt_end[n_pop_smolt] <- length(smolt_true)

slice_esc_start <- vector(length=n_pop_esc)
slice_esc_start[1] <- 1
slice_esc_end <- vector(length=n_pop_esc)
slice_esc_end[n_pop_esc] <- length(esc_true)

slice_harvest_start <- vector(length=n_pop_catch)
slice_harvest_start[1] <- 1
slice_harvest_end <- vector(length=n_pop_catch)
slice_harvest_end[n_pop_catch] <- length(harvest_true)

slice_MS_start <- vector(length=n_pop_MS)
slice_MS_start[1] <- 1
slice_MS_end <- vector(length=n_pop_MS)
slice_MS_end[n_pop_MS] <- length(MS_true)

for(p in 2:n_pop_smolt){
  slice_smolt_start[p] <- slice_smolt_start[p-1] + length(na.omit(coho_dat_full$Smolt.Abundance[coho_dat_full$pop==pop_smolt[p-1]]))
}
slice_smolt_end[1:(n_pop_smolt-1)] <- slice_smolt_start[2:n_pop_smolt]-1


for(p in 2:n_pop_esc){
  slice_esc_start[p] <- slice_esc_start[p-1] + length(na.omit(coho_dat_full$Spawners[coho_dat_full$pop==pop_esc[p-1]]))
}
slice_esc_end[1:(n_pop_esc-1)] <- slice_esc_start[2:n_pop_esc]-1


for(p in 2:n_pop_catch){
  slice_harvest_start[p] <- slice_harvest_start[p-1] + length(na.omit(coho_dat_full$Harvest[coho_dat_full$pop==pop_catch[p-1]]))
}
slice_harvest_end[1:(n_pop_catch-1)] <- slice_harvest_start[2:n_pop_catch]-1


for(p in 2:n_pop_MS){
  slice_MS_start[p] <- slice_MS_start[p-1] + length(na.omit(coho_dat_full$Fishery_Plus_Escapement[coho_dat_full$pop==pop_MS[p-1]]))
}
slice_MS_end[1:(n_pop_MS-1)] <- slice_MS_start[2:n_pop_MS]-1

```

```{r orig_stan_mod_fit}
#dropping iter for testing but otherwise using original function default control args on L456-7
#actual fit on L1272 uses 20K iter and 5 chains but otherwise same
n_iter=200; n_thin=1; n_adapt=0.99; n_tree=10.25; n_chain=3
sigma_esc = 0.2; mod_filename='LD_coho_forecast_6_2_4_fit'; cast_pop=c(1:36)

#in original "coord" is an argument passed object, directly from dat_list$coord
#here using sf revised version
#also needed convert all within list assignments from ",-" to "=" so stan sees named list
#and deal with 36 vs 44 pops
mod_fit <- stan(
  file = 'LD_coho_forecast_6_2_4.stan', 
  data = list(
    n_year = length(unique(coho_dat_full$Calendar.Year)),
    n_pop = nrow(coho_space), #length(unique(coho_dat_full$pop)),
    pop_smolt = pop_smolt,
    pop_esc = pop_esc,
    pop_catch = pop_catch,
    pop_MS = pop_MS,
    n_pop_smolt =n_pop_smolt,
    n_pop_esc = n_pop_esc,
    n_pop_catch = n_pop_catch,
    n_pop_MS = n_pop_MS,
    stream_dist = aggregate(coho_dat_full$KM, by=list('Population'=coho_dat_full$Population), mean)$x,
    smolt_true = smolt_true,
    esc_true = esc_true,
    MS_true = MS_true,
    harvest_true = harvest_true,
    smolt_dat = smolt_dat,
    esc_dat = esc_dat,
    harvest_dat = harvest_dat,
    MS_dat_x = round(MS_dat_x),
    MS_dat_N = round(MS_dat_N),
    n_smolt = length(smolt_dat),
    n_esc = length(esc_dat),
    n_harvest = length(harvest_dat),
    n_MS = length(MS_dat_x),
    #sigma_catch = sigma_catch,
    sigma_esc = sigma_esc,
    #sigma_smolt = sigma_smolt,
    n_hatchery = length(unique(na.omit(coho_dat_full$pop[coho_dat_full$Hatchery==1]))),
    hatchery = which(pop_MS %in% unique(na.omit(coho_dat_full$pop[coho_dat_full$Hatchery==1]))),
    wild = which(pop_MS %in% unique(na.omit(coho_dat_full$pop[coho_dat_full$Hatchery==0]))),
    slice_smolt_start = slice_smolt_start,
    slice_smolt_end = slice_smolt_end,
    slice_esc_start = slice_esc_start,
    slice_esc_end =  slice_esc_end,
    slice_harvest_start = slice_harvest_start,
    slice_harvest_end =  slice_harvest_end,
    slice_MS_start = slice_MS_start,
    slice_MS_end =  slice_MS_end,
    u=matrix(1, nrow=1, ncol=nrow(coho_space)),  #matrix(1, nrow=1, ncol=n_pop),
    dist = as.matrix(dist(sf::st_coordinates(sf_coord), 'euclidean', diag = TRUE, upper = TRUE)/10000)
    # dist = as.matrix(dist(coord, 'euclidean', diag=TRUE, upper=TRUE)/10000)
    # #dist = as.matrix(dist(coord[sound,]/10000, 'euclidean', diag=TRUE, upper=TRUE))
  ),iter = n_iter, chains = n_chain, control=list(adapt_delta=n_adapt, max_treedepth=n_tree), thin=n_thin, seed=666)

#saveRDS(mod_fit, paste(mod_filename,'.rds',sep=''))

```

## revised STIPM

```{r revised_stan_data}
#declare a few intermediates to reduce the repeated filter calls around different data elements
tbl_coho_stan <- list(
  smolt = tbl_coho |> filter(!is.na(`Smolt Abundance`)),
  esc = tbl_coho |> filter(!is.na(spwn)),
  catch = tbl_coho |> filter(!is.na(hvst)) |>
    #override the single bad harvest val related to neg escapement/ER>1 issue above
    mutate(hvst = abs(hvst)),
  MS = tbl_coho |> filter(!is.na(Release_No)), #note both "Release_No" and "Fishery_Plus_Escapement" are used in orig, setting up potential divergence conflict
  rtrn = tbl_coho |> 
    mutate(
      hvst = abs(hvst), #same fix as catch
      rtrn = spwn + hvst
      ) |>
    filter(!is.na(rtrn))
)
```

```{r revised_stan_fit_stipm}
#dropping iter for testing but otherwise using original function default control args on L456-7
#actual fit on L1272 uses 20K iter and 5 chains but otherwise same

#would prefer better within-list naming convention, but for now left as-is other than reorg around data types
fit_stipm <- stan(
  file = 'LD_coho_forecast_6_2_4.stan', 
  iter = 200,
  chains = 3,
  control = list(
    adapt_delta = 0.99,
    max_treedepth = 10.25
    ),
  thin = 1,
  seed = 666,
  data = list(
    n_year = length(unique(tbl_coho$`Calendar Year`)), #orig includes NA with 1986:2018
    n_pop = length(unique(tbl_coho$pop_id)), #orig includes 8 additional IDs for plotting 'Name' only (i.e., no data)
    u = matrix(1, nrow = 1, ncol = length(unique(tbl_coho$pop_id))),
    dist = units::drop_units(sf::st_distance(sf_coord)/10000), #values are identical
    #could also: as.matrix(dist(sf::st_coordinates(coord), 'euclidean', diag = TRUE, upper = TRUE)/10000)
    
    pop_smolt = unique(tbl_coho_stan$smolt$pop_id), #pop_ids with smolt data 
    n_pop_smolt = length(unique(tbl_coho_stan$smolt$pop_id)),
    smolt_true = tbl_coho_stan$smolt$yr,
    smolt_dat = tbl_coho_stan$smolt$`Smolt Abundance`,
    n_smolt = nrow(tbl_coho_stan$smolt),
    
    pop_esc = unique(tbl_coho_stan$esc$pop_id),  # pop_ids with escapement data
    n_pop_esc = length(unique(tbl_coho_stan$esc$pop_id)),
    esc_true = tbl_coho_stan$esc$yr,
    esc_dat = tbl_coho_stan$esc$spwn,
    n_esc = nrow(tbl_coho_stan$esc),
    
    pop_catch = unique(tbl_coho_stan$catch$pop_id), #pop_ids with harvest data
    n_pop_catch = length(unique(tbl_coho_stan$catch$pop_id)),
    harvest_true = tbl_coho_stan$catch$yr,
    harvest_dat = tbl_coho_stan$catch$hvst,
    n_harvest = nrow(tbl_coho_stan$catch),
    
    pop_MS = unique(tbl_coho_stan$MS$pop_id), #pop_ids with marine survival data
    n_pop_MS = length(unique(tbl_coho_stan$MS$pop_id)),
    MS_true = tbl_coho_stan$MS$yr, #orig uses Fishery_Plus_Escapement rather than Release_No to filter...
    MS_dat_x = tbl_coho_stan$MS$Fishery_Plus_Escapement |> round(), #stan expects integer...
    MS_dat_N = tbl_coho_stan$MS$Release_No,
    n_MS = nrow(tbl_coho_stan$MS),
    
    stream_dist = tbl_coho |> group_by(pop) |> summarise(d = mean(KM, na.rm = T), .groups = "drop") |> select(d) |> unlist() |> as.numeric(),
    
    #elements called "sigma_catch" and "sigma_smolt" are commented out
    #this is a passed arg in the orig exec_fun()
    sigma_esc = 0.2,
    
    n_hatchery = filter(tbl_coho, hat == 1) |> distinct(pop_id) |> nrow(),
    #NOT WHAT WE WANT: hatchery = filter(tbl_coho_stan$MS, hat == 1) |> distinct(pop_id) |> pluck("pop_id"),
    hatchery = distinct(tbl_coho_stan$MS, pop_id, pop, hat) |> 
      mutate(hat_id = if_else(hat > 0, row_number(), NA_integer_)) |> 
      filter(!is.na(hat_id)) |>
      pluck("hat_id"),
    # ## intentional or subtle error in orig due to which() wrapping re-indexing?
    ## NOTE LEAVING AS-IS ORIG PENDING CLARIFICATION
    hatchery = which(pop_MS %in% unique(na.omit(coho_dat_full$pop[coho_dat_full$Hatchery==1]))),
    wild = which(pop_MS %in% unique(na.omit(coho_dat_full$pop[coho_dat_full$Hatchery==0]))),
    ### 
    # (pop_MS <- unique(coho_dat_full$pop[which(is.na(coho_dat_full$Release_No)==FALSE)])) #L470 orig
    # identical(pop_MS, unique(tbl_coho_stan$MS$pop_id)) #matching the set of IDs with marine survival data
    # coho_dat_full |> filter(pop %in% pop_MS, Hatchery == 1) |> distinct(pop) #IDs of pops with hatchery flag 1 presumably the goal?
    # coho_dat_full |> filter(!is.na(Release_No), Hatchery == 1) |> distinct(pop) #same with inline redeclare of pop_MS
    # which(pop_MS %in% unique(na.omit(coho_dat_full$pop[coho_dat_full$Hatchery==1]))) #NOT same...returns indexes of pop_MS
    # #was it meant to be population IDs or indices of pop_MS?
    # pop_MS[which(pop_MS %in% unique(na.omit(coho_dat_full$pop[coho_dat_full$Hatchery==1])))] #matches pluck'd version above...
    
    slice_smolt_start = tbl_coho_stan$smolt |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
    slice_smolt_end = tbl_coho_stan$smolt |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
    
    slice_esc_start = tbl_coho_stan$esc |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
    slice_esc_end = tbl_coho_stan$esc |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
    
    slice_harvest_start = tbl_coho_stan$catch |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
    slice_harvest_end = tbl_coho_stan$catch |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
    
    slice_MS_start = tbl_coho_stan$MS |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
    slice_MS_end = tbl_coho_stan$MS |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid")
  )
)
```

## revised AR1

```{r stan_fit_ar1}
# #	only a few population-years missing estimates
# tbl_coho_stan$rtrn |> count(pop_id) |> print(n=50)
  
#why is n_year "+1" here?
#"_tot" refers to "total return"
# a "n_year_true_tot" gets declared but not passed and not expected by AR stan
fit_ar1 <- stan(
  file = 'LD_coho_forecast_AR_ind_2.stan',
  iter = 400,
  chains = 4,
  control = list(
    adapt_delta = 0.99,
    max_treedepth = 10.25
  ),
  thin = 1,
  seed = 666,
  data = list(
    #Number of years (total, includes several missing years for some stocks)
    n_year = length(unique(tbl_coho$`Calendar Year`)) + 1,
    #Number of total populations    
    n_pop = length(unique(tbl_coho$pop_id)),
    #Number of populations with return data
    n_pop_tot = length(unique(tbl_coho_stan$rtrn$pop_id)),
    #Which populations possess return data
    pop_tot = unique(tbl_coho_stan$rtrn$pop_id),
    #Length of the return data vectors
    n_tot = nrow(tbl_coho_stan$rtrn), #length(tot_dat)
    #Vectors of all return data across all populations
    tot_dat = tbl_coho_stan$rtrn$rtrn,
    #Vectors of the indices identifying which years are those with non-NA data for the return data
    tot_true = tbl_coho_stan$rtrn$yr,
    #Paired vectors of slice points indicating the beginning, and end of the data for a particular population
    slice_tot_start = tbl_coho_stan$rtrn |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
    slice_tot_end = tbl_coho_stan$rtrn |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid")
    )
  )
```

```{r fit_ar1_summary}
#beginning to examine stan fit objects

# #seem really unwieldy, could use some improvement
# #but more or less following orig for now
# fit_ar1_df <- as.data.frame(fit_ar1) |> tibble()
# grep(pattern = "adult_pred", colnames(fit_ar1_df), value = T)
# fit_ar1_df[, "adult_pred[36]"]
# fit_ar1_df |> 
#   select(contains("adult_pred")) |> 
#   pivot_longer(names_to = "adult_pred_pop", values_to = "pred", cols = everything()) |> 
#   group_by(adult_pred_pop) |> 
#   summarise(across(pred, list(median = median)), .groups = "drop") |> print(n=50)
  
#only really need the "merged chains" output from summary()?
fit_ar1_summary <- list(
  #adult_est is [year, pop] indexed
  adult_est = summary(fit_ar1, pars = "adult_est", probs = c(0.1, 0.5, 0.9))$summary |> 
    as.data.frame() |> rownames_to_column("stan_out") |> tibble() |> 
    mutate(
      var = str_extract(stan_out, "[a-z]+[:punct:][a-z]+"),
      year = (min(tbl_coho$`Calendar Year`) - 1) + as.numeric(str_extract(stan_out, "[0-9]{1,2}")),
      pop_id = str_remove(stan_out, var) |> str_split(",") |> map_dbl( ~str_extract(.x[2], "[0-9]+") |> as.numeric())
    ) |> 
    left_join(tbl_coho |> distinct(pop_id, pop), by = "pop_id")
  ,
  #adult_pred is pop indexed only
  adult_pred = summary(fit_ar1, pars = "adult_pred", probs = c(0.1, 0.5, 0.9))$summary |> 
    as.data.frame() |> rownames_to_column("stan_out") |> tibble() |> 
    mutate(
      var = str_extract(stan_out, "[a-z]+[:punct:][a-z]+"),
      pop_id = as.numeric(str_extract(stan_out, "[0-9]+"))
    ) |> 
    left_join(tbl_coho |> distinct(pop_id, pop), by = "pop_id")
)

fit_ar1_summary$adult_pred |> print(n = 100)
fit_ar1_summary$adult_est |> print(n = 100)

```

```{r popid_vectors}
maybe_drop_popids <- c(
#these should probably go...
  10, #not sure what this actually is...
  24, #Pt Gamble, fixed BKFRAM input, not a pop
#these maybe...
  14, #Dungeness, recent estimate difficulties, but smolt ests
  16, #Elwha, recent method changes and special habitat case 
  18, #Green, relevance, recent estimate difficulties, but smolt ests
  21, #LkWA, relevance/pop size
  23 #Nooksack, proxy not an escp est, but smolt ests
  )

focal_popids <- c(36:33, 29, 26)
focal_popids <- 36
```

```{r playing_with_fit_ar1}
tbl_coho |> 
  #filter( !(pop_id %in% maybe_drop_popids)) |> 
  filter( pop_id %in% focal_popids) |> 
  select(year = `Calendar Year`, pop_id, pop, spwn, hvst) |> 
  pivot_longer(c(spwn, hvst), names_to = "var", values_to = "val") |> 
  ggplot(aes(year, val, fill = var, color = var)) +
  geom_col(position = "stack") +
  geom_ribbon(
    aes(x = year, ymin = `10%`, ymax = `90%`), inherit.aes = F,
    data = fit_ar1_summary$adult_est |> 
      filter( pop_id %in% focal_popids) |> 
      select(year, pop_id, pop, var, `10%`, `90%`),
    alpha = 0.3, color = "gold", fill = "gold") +
  geom_line(
    data = fit_ar1_summary$adult_est |> 
      filter( pop_id %in% focal_popids) |> 
      select(year, pop_id, pop, var, val = `50%`)) +
  scale_fill_grey(aesthetics = c("fill", "color")) +
  scale_x_continuous(n.breaks = 12,  guide = guide_axis(n.dodge = 2)) +
  scale_y_continuous("Return", labels = scales::comma) +
  facet_wrap(~pop_id + pop, scales = "free", labeller = label_wrap_gen(multi_line = F), ncol = 1)

```


# sliding refits?

Basic approach of passing a data subset could be stretching (y1:yn) or sliding ([yn-window]:yn).

Generally prefer sliding, and arguably considerably weaker data earlier in the series, but could be good reasons to stretch here...

```{r}
library(slider)

focal_popids <- 35:36

#dummy example to rough out the pattern
foo <- tbl_coho_stan$rtrn |> 
  filter( pop_id %in% focal_popids) |> 
  select(year = `Calendar Year`, pop_id, pop, rtrn) |>
  group_by(pop_id, pop) |> 
  mutate(
    rtrn_mu5 = slide_dbl(rtrn, mean, .before = 5),
    lm_fit = slide(
      .x = cur_data(), #the subset of rows
      .f = ~lm(rtrn ~ year, data = .x), #the thing to do to them
      .before = 5, #how far back to look
      .complete = T
    ),
    lm_pred = lm_fit |> 
      map_dbl(~if_else(is.null(.x), NA_real_, last(.x$fitted.values)))
  ) |> 
  ungroup()

foo |> 
  select(year, pop_id, pop, rtrn, rtrn_mu5, lm_pred) |> 
  pivot_longer(cols = -c(year, pop_id, pop), names_to = "var", values_to = "val") |> 
  {\(x) 
  ggplot(x, aes(year, val, color = var)) +
  geom_line(data = filter(x, var != "rtrn")) +
  geom_point(data = filter(x, var == "rtrn")) + 
  scale_x_continuous(n.breaks = 10,  guide = guide_axis(n.dodge = 2)) +
  facet_wrap(~pop_id + pop, scales = "free", ncol = 1)
  }()

```




# compare skill