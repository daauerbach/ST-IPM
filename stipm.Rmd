---
title: "stipm"
author: "dan.auerbach@dfw.wa.gov modifying DeFilippo et al. 2021 in consultation with Thomas.Buehrens@dfw.wa.gov"
date: "`r Sys.Date()`"
editor_options: 
  chunk_output_type: console
output: 
  wdfwTemplates::wdfw_html_format

---

This script updates and extends the [original implementation](https://github.com/lukasdefilippo/ST-IPM) of [DeFilippo et al.'s (2021)](https://www.sciencedirect.com/science/article/pii/S0165783621001429) "Spatiotemporal Integrated Population Model" (ST-IPM) of Washington state natural origin coho (*O. kisutch*) returns, with initial application to annual preseason forecasts of Willapa Bay returning adults.

# setup

```{r setup, results = FALSE, warning = FALSE, message = FALSE}
knitr::opts_chunk$set(echo = TRUE, results = FALSE, warning = FALSE, message = FALSE)

library("tidyverse")
library("odbc"); library("DBI")
library("rstan")
options(mc.cores = 10) #12 on DA machine
rstan_options(auto_write = TRUE)
theme_set(theme_light())

f_orig <- "Coho_IPM_spatial_AR.r"

fp <- list(
  fram_mdb_pre2010 = "O:/code/coho_fram_validation/FramVS2-PSC-Coho-Backwards-thru2016 use me.mdb",
  fram_mdb_2010onward =  "O:/code/coho_fram_validation/PSC_CoTC_PostSeason_CohoFRAMDB_2010thru2019_021021.mdb",
  coho_file = 'Coho data_3-30-20.csv',
  cwt_file = 'CWT_FRAM_Matches_complete20200303.csv',
  stream_file = 'Coho_KM_3.31.2020_2.csv'
  )

#lu_stock <- readxl::read_excel("stipm_pops_crosscheck.xlsx")
#lu_stock |> filter(FRAM_StockID != 10, FRAM_StockID != 24) |> pluck("FRAM_StockID") |> paste0(collapse = ",")
#drop 13 and 43
fram_stocks <- c(105,93,89,45,51,55,75,81,61,23,149,63,107,115,111,157,97,135,153,101,69,1,85,139,131,127,145,11,17,59,35,29,117,161)

maybe_drop_popids <- c(
#these should probably go...
  10, #not sure what this actually is...
  24, #Pt Gamble, fixed BKFRAM input, not a pop
#these maybe...
  14, #Dungeness, recent estimate difficulties, but smolt ests
  16, #Elwha, recent method changes and special habitat case 
  18, #Green, relevance, recent estimate difficulties, but smolt ests
  21, #LkWA, relevance/pop size
  23 #Nooksack, proxy not an escp est, but smolt ests
  )

focal_popids <- c(36:33, 29, 26)
focal_popids <- 36

```

# data

The analysis relies on per-stock escapement and harvest estimates compiled in post-season [coho FRAM](https://github.com/FRAMverse/fram_doc) runs as well as CWT-based marine survival estimates derived from RMIS.

Here, the original data ingest and preparation flow has been condensed following line-wise deconstruction, reconstruction and object testing.

The resulting "full data" object forms the basis for subsequent model-fitting, prediction and evaluation.

```{r tbl_coho_full}
#presumably this will change further with a reduced/updated FRAM dataset
#for now preserving smoltCWT<-->FRAMunit assignment choices in original
#and largely preserving the order of operations (e.g., multiple filter())

drop_pop <- c("Queets", "Clearwater", 'Bell Creek', 'Johnson Creek', 'Jimmy Come Lately Creek',
              'Deep Creek', 'McDonald Creek', 'Siebert Creek', 'Salt Creek', 'Discovery Bay',
              'East Twin Creek', 'West Twin Creek', 'Northeast Hood Canal')

drop_cwt_surv <- c("Minter Crk H", "Baker H", "Satsop H") 

tbl_coho <- readr::read_csv(fp$coho_file) |> #1709x21
  mutate(
    pop = case_when(
      !is.na(`SaSI Population`) ~ `SaSI Population`,
      is.na(`SaSI Population`) & is.na(SubPopulation) ~ `Managment Unit (FRAM)`,
      is.na(`SaSI Population`) & !is.na(SubPopulation) ~ SubPopulation
    ),
    spwn = case_when(
      !is.na(`SaSI Population`) ~ `SASI Natural Origin Abundance`,
      is.na(`SaSI Population`) & is.na(SubPopulation) ~ `Age 3 Escapement (FRAM)`,
      is.na(`SaSI Population`) & !is.na(SubPopulation) ~ `SupPopulation Escapement`
    ),
    spwn = if_else(pop=="Discovery Bay", `SASI CompositeOrigin Abundance`, abs(spwn)) #corrects negative val for 2005 A12A Wild, orig L152
    ,
    hvst = spwn / (1/`Harvest (% FRAM)` - 1) 
  ) |> 
  filter( !(pop %in% drop_pop) ) |> 
  select(`Calendar Year`, `Smolt Abundance`, Latitude, Longitude, pop, spwn, hvst) |> 
  inner_join(
    readr::read_csv(fp$stream_file) |> 
      filter(Population != "", !is.na(Population)) |> #no NAs in the current csv, but left for now
      select(pop = Population, KM)
    ,
    by = "pop") |> 
  full_join(
    readr::read_csv(fp$cwt_file) |> 
      mutate(
        hat = if_else(stringr::str_detect(`Smolt Ocean Survival Population`, " H$"), 1, 0)
      ) |> 
      filter( !(`Smolt Ocean Survival Population` %in% drop_cwt_surv)) |> 
      select(pop = `Managment Unit (FRAM)`, `Calendar Year`, `Smolt Ocean Survival Population`, Fishery_Plus_Escapement, Release_No, hat)
    ,
    by = c("pop", "Calendar Year")) |> 
  filter(`Calendar Year` > 1985) |> 
  bind_rows(
    tibble(`Calendar Year` = 2013, yr = 28, pop = "Area 7-7A Independent Wild"),
    tibble(`Calendar Year` = 2004, yr = 19, pop = "Port Gamble Bay Wild"),
    tibble(`Calendar Year` = 2000:2001, yr = 15:16, pop = "Grays Harbor Miscellaneous Wild")
  ) |>
  left_join(
    bind_rows(
      tibble(pop = "Green River Wild", Long = -122.2145, Lat = 47.3519),
      tibble(pop = "Area 10E Miscellaneous Wild", Long = -122.8242, Lat = 47.5896)
    )
    , by = "pop") |>
  mutate(
    Longitude = if_else(is.na(Long), Longitude, Long), Long = NULL,
    Latitude = if_else(is.na(Lat), Latitude, Lat), Lat = NULL,
    Basin = if_else(Longitude < -123.80, 0, 1),
    `Smolt Abundance` = if_else(pop == "Puyallup River Wild", NA_real_, `Smolt Abundance`),
    hvst = if_else(stringr::str_detect(pop, "Quillayute River") & `Calendar Year` <= 1987, NA_real_, hvst),
    pop_id = as.numeric(factor(pop)),
    yr = `Calendar Year` - min(`Calendar Year`) + 1
  ) |> 
  arrange(pop)

sf_coord <- tbl_coho |> 
  group_by(pop, pop_id) |> 
  summarise(long = median(Longitude, na.rm = T), lat = median(Latitude, na.rm = T), .groups = "drop") |> 
  sf::st_as_sf(coords = c("long", 'lat'), crs = sf::st_crs("+proj=longlat +datum=WGS84")) |> 
  sf::st_transform(crs = sf::st_crs("+proj=utm +zone=10T ellps=WGS84"))

```

Skipping recreation of `state_cast` data object of compiled prior forecasts.

## Cross-reference

Dump a file for discussion and review of included series.

```{r dataset_out}
# tbl_coho |> 
#   group_by(pop_id, pop) |> 
#   summarise(
#     year_min = min(`Calendar Year`),
#     year_max = max(`Calendar Year`),
#     nobs_any = n(),
#     across(c(spwn, hvst, `Smolt Abundance`, Release_No), ~sum(!is.na(.))),
#     .groups = "drop"
#   ) |> #print(n = 50)
#   ##writexl::write_xlsx("stipm_pops_crosscheck.xlsx")
```

Pull in recent BackwardsFRAM and Cohort tables

```{r read_bkfram_cohort}
#manually crossref'd to "fram_coho_escapement_2021_020121.xlsx"
#comparing 

db <- "O:/code/coho_fram_validation/PSC_CoTC_PostSeason_CohoFRAMDB_2010thru2019_021021.mdb"
db_con <- DBI::dbConnect(drv = odbc::odbc(),
  .connection_string = paste0("Driver={Microsoft Access Driver (*.mdb, *.accdb)};DBQ=",db,";"))
tbl(db_con, "RunID") |> select(RunID, RunYear, TAMMName) #34:43, 2010:2019
#no idea why RunID == 0 is in this database...
#or why 39/2015 has 246 (vs 93 to 95 in other runs/years)...maybe just 0s for all stocks
bkfram <- tbl(db_con, "BackwardsFRAM") |> 
  filter(between(RunID, 34, 43)) |> 
  select(RunID, StockID, escp = TargetEscAge3) |> 
  left_join(tbl(db_con, "RunID") |> select(RunID, RunYear, RunTitle, TAMMName), by = "RunID") |> 
  left_join(tbl(db_con, "Stock") |> filter(Species == "COHO") |> select(StockID, StockLongName), by = "StockID") |> 
  collect()

cohort <- tbl(db_con, "Cohort") |> 
  filter(between(RunID, 34, 43)) |> 
  select(-PrimaryKey) |> 
  left_join(tbl(db_con, "RunID") |> select(RunID, RunYear, RunTitle, TAMMName), by = "RunID") |> 
  left_join(tbl(db_con, "Stock") |> filter(Species == "COHO") |> select(StockID, StockLongName), by = "StockID") |> 
  collect()

DBI::dbDisconnect(db_con)
```

```{r crossref_bkfram_cohort}
# #not sure which, if any, of these are comparable...
# cohort |> #count(RunID, RunYear) |> 
#   select(RunYear, StockID, StockLongName, TimeStep, Cohort, StartCohort) |> 
#   filter(
#     str_detect(StockLongName, "Wild|Natural"),
#     StockID < 165, TimeStep == 1
#     )

bkfram |> #count(RunID, RunYear) |> 
  select(RunYear, StockID, StockLongName, escp) |> 
  filter(
    str_detect(StockLongName, "Wild|Natural"),
    !(RunYear == 2015 & escp == 0),
    StockID < 165,
    between(RunYear, 2016, 2017)
    ) |> 
  pivot_wider(names_from = RunYear, values_from = escp) |> 
  print(n = 100)

tbl_coho |> 
  select(`Calendar Year`, pop, spwn) |> 
  filter(between(`Calendar Year`, 2016, 2017)) |> 
  pivot_wider(names_from = `Calendar Year`, values_from = spwn) |> 
  print(n = 40)

```

## alternative ingest from CoTC post-season databases

Coho FRAM tracks age 3 fish across 5 time steps corresponding to a calendar year. It includes unmarked and marked units of both natural and hatchery stocks. Prior to 1998, the marked and unmarked components in validation runs were each simply defined as 50% of the hatchery or wild values.

The current set of post-season runs is split across two Access file databases corresponding to pre-2010 and 2010-onward.

```{r}
#preferable to read from "Escapement" table here?

read_coho_backwards <- function (db, runs = NULL, stocks = NULL) {

  db_con <- DBI::dbConnect(drv = odbc::odbc(),
    .connection_string = paste0("Driver={Microsoft Access Driver (*.mdb, *.accdb)};DBQ=", db, ";"))

  #lazy, full table then reduce as specified
  bk <- dplyr::tbl(db_con, "BackwardsFRAM") |> dplyr::select(RunID, StockID, escp = TargetEscAge3)
  if (!is.null(runs)) { bk <- dplyr::filter(bk, RunID %in% runs) }
  if (!is.null(stocks)) { bk <- dplyr::filter(bk, StockID %in% stocks) }

  #associate metainfo and pull
  bk <- bk |> 
    dplyr::left_join(
      dplyr::tbl(db_con, "RunID") |>  dplyr::select(RunID, RunYear, RunName), 
      by = "RunID") |>
    dplyr::left_join(
      dplyr::tbl(db_con, "Stock") |> dplyr::filter(Species == "COHO") |> dplyr::select(StockID, StockLongName),
      by = "StockID") |>
    dplyr::collect() |> 
    dplyr::arrange(RunYear, StockID)

  DBI::dbDisconnect(db_con)
  
  return(bk)
}

read_coho_mort <- function (db, runs = NULL, stocks = NULL) {
  
  db_con <- DBI::dbConnect(drv = odbc::odbc(),
    .connection_string = paste0("Driver={Microsoft Access Driver (*.mdb, *.accdb)};DBQ=", db, ";"))
  
  #lazy, full table then reduce as specified
  m <- dplyr::tbl(db_con, "Mortality") |> dplyr::select(-PrimaryKey)
  if (!is.null(runs)) { m <- dplyr::filter(m, RunID %in% runs) }
  if (!is.null(stocks)) { m <- dplyr::filter(m, StockID %in% stocks) }

  #associate metainfo and pull
  m <- m |> 
    dplyr::left_join(
      dplyr::tbl(db_con, "RunID") |>  dplyr::select(RunID, RunYear, RunName), 
      by = "RunID") |>
    dplyr::left_join(
      dplyr::tbl(db_con, "Stock") |> dplyr::filter(Species == "COHO") |> dplyr::select(StockID, StockLongName),
      by = "StockID") |>
    dplyr::left_join(
      dplyr::tbl(db_con, "Fishery") |> dplyr::filter(Species == "COHO") |> dplyr::select(FisheryID, FisheryName), 
      by = "FisheryID") |> 
    dplyr::collect() |> 
    dplyr::arrange(RunYear, FisheryID, TimeStep, StockID)

  DBI::dbDisconnect(db_con)
  
  return(m)
}

fram <- list(
  bk = bind_rows(
    read_coho_backwards(fp$fram_mdb_pre2010, runs = c(2:22,25:28), stocks = fram_stocks) 
    ,
    read_coho_backwards(fp$fram_mdb_2010onward, runs = 34:43, stocks = fram_stocks)
  )
  ,
  m = bind_rows(
    read_coho_mort(fp$fram_mdb_pre2010, runs = c(2:22,25:28), stocks = fram_stocks)
    ,
    read_coho_mort(fp$fram_mdb_2010onward, runs = 34:43, stocks = fram_stocks)
  ) |>
    mutate(mort = LandedCatch + NonRetention + Shaker + DropOff + MSFLandedCatch + MSFNonRetention + MSFShaker + MSFDropOff) |> 
    group_by(RunYear, StockID, StockLongName) |> 
    summarise(mort = sum(mort), .groups = "drop")
)


fram$bk |> #count(RunID, RunYear) |> 
  select(RunYear, StockID, StockLongName, escp) |> 
  # filter(
  #   !(RunYear == 2015 & escp == 0),
  #   between(RunYear, 2016, 2017)
  #   ) |> 
  pivot_wider(names_from = RunYear, values_from = escp) |> 
  print(n = 100)


fram$m |> 
  pivot_wider(names_from = RunYear, values_from = mort)

# #looks like going to need to redo against Escapement table?
#   tbl(db_con, "Escapement") %>%
#     filter(RunID %in% runs, StockID %in% stocks) %>% collect() %>%
#     left_join(tbl(db_con, "Stock") %>% filter(Species == "COHO") %>% select(StockID, StockName) %>% collect(), by = "StockID") %>%
#     mutate(h_w = str_sub(StockName,3,20) %>% `==`(.,"willaw") %>% if_else("Wild","Hatchery")) %>%
#     left_join(tbl(db_con, "RunID") %>% select(RunID, year = RunYear) %>% collect(), by = "RunID") %>%
#     group_by(year, h_w) %>% summarise(escp = sum(Escapement)) %>% ungroup(),
  
  
```

# fit stan

Here we declare a few intermediates to reduce repeated filter calls around different data elements (reaching the vectors with no missing data required by stan).

```{r tbl_coho_stan}
tbl_coho_stan <- list(
  smolt = tbl_coho |> filter(!is.na(`Smolt Abundance`)),
  esc = tbl_coho |> filter(!is.na(spwn)),
  catch = tbl_coho |> filter(!is.na(hvst)) |>
    #override the single bad harvest val related to neg escapement/ER>1 issue above
    mutate(hvst = abs(hvst)),
  MS = tbl_coho |> filter(!is.na(Release_No)), #note both "Release_No" and "Fishery_Plus_Escapement" are used in orig, setting up potential divergence conflict
  rtrn = tbl_coho |> 
    mutate(
      hvst = abs(hvst), #same fix as catch
      rtrn = spwn + hvst
      ) |>
    filter(!is.na(rtrn))
)
```

## STIPM

```{r revised_stan_fit_stipm}
#dropping iter for testing but otherwise using original function default control args on L456-7
#actual fit on L1272 uses 20K iter and 5 chains but otherwise same

#would prefer better within-list naming convention, but for now left as-is other than reorg around data types
fit_stipm <- stan(
  file = 'LD_coho_forecast_6_2_4.stan', 
  iter = 1000,
  chains = 4,
  control = list(
    adapt_delta = 0.99,
    max_treedepth = 10.25
    ),
  thin = 1,
  seed = 222,
  data = list(
    n_year = length(unique(tbl_coho$`Calendar Year`)), #orig includes NA with 1986:2018
    n_pop = length(unique(tbl_coho$pop_id)), #orig includes 8 additional IDs for plotting 'Name' only (i.e., no data)
    u = matrix(1, nrow = 1, ncol = length(unique(tbl_coho$pop_id))),
    dist = units::drop_units(sf::st_distance(sf_coord)/10000), #values are identical
    #could also: as.matrix(dist(sf::st_coordinates(coord), 'euclidean', diag = TRUE, upper = TRUE)/10000)
    
    pop_smolt = unique(tbl_coho_stan$smolt$pop_id), #pop_ids with smolt data 
    n_pop_smolt = length(unique(tbl_coho_stan$smolt$pop_id)),
    smolt_true = tbl_coho_stan$smolt$yr,
    smolt_dat = tbl_coho_stan$smolt$`Smolt Abundance`,
    n_smolt = nrow(tbl_coho_stan$smolt),
    
    pop_esc = unique(tbl_coho_stan$esc$pop_id),  # pop_ids with escapement data
    n_pop_esc = length(unique(tbl_coho_stan$esc$pop_id)),
    esc_true = tbl_coho_stan$esc$yr,
    esc_dat = tbl_coho_stan$esc$spwn,
    n_esc = nrow(tbl_coho_stan$esc),
    
    pop_catch = unique(tbl_coho_stan$catch$pop_id), #pop_ids with harvest data
    n_pop_catch = length(unique(tbl_coho_stan$catch$pop_id)),
    harvest_true = tbl_coho_stan$catch$yr,
    harvest_dat = tbl_coho_stan$catch$hvst,
    n_harvest = nrow(tbl_coho_stan$catch),
    
    pop_MS = unique(tbl_coho_stan$MS$pop_id), #pop_ids with marine survival data
    n_pop_MS = length(unique(tbl_coho_stan$MS$pop_id)),
    MS_true = tbl_coho_stan$MS$yr, #orig uses Fishery_Plus_Escapement rather than Release_No to filter...
    MS_dat_x = tbl_coho_stan$MS$Fishery_Plus_Escapement |> round(), #stan expects integer...
    MS_dat_N = tbl_coho_stan$MS$Release_No,
    n_MS = nrow(tbl_coho_stan$MS),
    
    stream_dist = tbl_coho |> group_by(pop) |> summarise(d = mean(KM, na.rm = T), .groups = "drop") |> select(d) |> unlist() |> as.numeric(),
    
    #elements called "sigma_catch" and "sigma_smolt" are commented out
    #this is a passed arg in the orig exec_fun()
    sigma_esc = 0.2,
    
    n_hatchery = filter(tbl_coho, hat == 1) |> distinct(pop_id) |> nrow(),
    #NOT WHAT WE WANT: hatchery = filter(tbl_coho_stan$MS, hat == 1) |> distinct(pop_id) |> pluck("pop_id"),
    hatchery = distinct(tbl_coho_stan$MS, pop_id, pop, hat) |> 
      mutate(hat_id = if_else(hat > 0, row_number(), NA_integer_)) |> 
      filter(!is.na(hat_id)) |> pluck("hat_id"),
    wild = distinct(tbl_coho_stan$MS, pop_id, pop, hat) |> 
      mutate(hat_id = if_else(hat < 1, row_number(), NA_integer_)) |> 
      filter(!is.na(hat_id)) |> pluck("hat_id"), 
 
    slice_smolt_start = tbl_coho_stan$smolt |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
    slice_smolt_end = tbl_coho_stan$smolt |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
    
    slice_esc_start = tbl_coho_stan$esc |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
    slice_esc_end = tbl_coho_stan$esc |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
    
    slice_harvest_start = tbl_coho_stan$catch |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
    slice_harvest_end = tbl_coho_stan$catch |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
    
    slice_MS_start = tbl_coho_stan$MS |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
    slice_MS_end = tbl_coho_stan$MS |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid")
  )
)
```

## AR1

```{r stan_fit_ar1}
# #	only a few population-years missing estimates
# tbl_coho_stan$rtrn |> count(pop_id) |> print(n=50)
  
#why is n_year "+1" here?
#"_tot" refers to "total return"
# a "n_year_true_tot" gets declared but not passed and not expected by AR stan
fit_ar1 <- stan(
  file = 'LD_coho_forecast_AR_ind_2.stan',
  iter = 1000,
  chains = 4,
  control = list(
    adapt_delta = 0.99,
    max_treedepth = 10.25
  ),
  thin = 1,
  seed = 222,
  data = list(
    #Number of years (total, includes several missing years for some stocks)
    n_year = length(unique(tbl_coho$`Calendar Year`)) + 1,
    #Number of total populations    
    n_pop = length(unique(tbl_coho$pop_id)),
    #Number of populations with return data
    n_pop_tot = length(unique(tbl_coho_stan$rtrn$pop_id)),
    #Which populations possess return data
    pop_tot = unique(tbl_coho_stan$rtrn$pop_id),
    #Length of the return data vectors
    n_tot = nrow(tbl_coho_stan$rtrn), #length(tot_dat)
    #Vectors of all return data across all populations
    tot_dat = tbl_coho_stan$rtrn$rtrn,
    #Vectors of the indices identifying which years are those with non-NA data for the return data
    tot_true = tbl_coho_stan$rtrn$yr,
    #Paired vectors of slice points indicating the beginning, and end of the data for a particular population
    slice_tot_start = tbl_coho_stan$rtrn |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
    slice_tot_end = tbl_coho_stan$rtrn |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid")
    )
  )
```

## summarize fitted

```{r fit_ar1_summary}
#TB suggest appending "adult_pred" as the 1-ahead "forecast"
#little wrapper to mod later, revise reliance on global `tbl_coho` for pop string lu
#only really need the "merged chains" output from summary() if continuing this route?

fit_smry <- function(fit_obj, p = c(0.1, 0.5, 0.9)) {
  lu <- tbl_coho |> distinct(pop_id, pop)
  x <- list(
    #adult_est is [year, pop] indexed
    adult_est = summary(fit_obj, pars = "adult_est", probs = p)$summary |> 
      as.data.frame() |> rownames_to_column("stan_out") |> tibble() |> 
      mutate(
        var = str_extract(stan_out, "[a-z]+[:punct:][a-z]+"),
        year = (min(tbl_coho$`Calendar Year`) - 1) + as.numeric(str_extract(stan_out, "[0-9]{1,2}")),
        pop_id = str_remove(stan_out, var) |> str_split(",") |> map_dbl( ~str_extract(.x[2], "[0-9]+") |> as.numeric())
      ) |> 
      left_join(lu, by = "pop_id")
    ,
    #adult_pred is pop indexed only
    adult_pred = summary(fit_obj, pars = "adult_pred", probs = p)$summary |> 
      as.data.frame() |> rownames_to_column("stan_out") |> tibble() |> 
      mutate(
        var = str_extract(stan_out, "[a-z]+[:punct:][a-z]+"),
        pop_id = as.numeric(str_extract(stan_out, "[0-9]+"))
      ) |> 
      left_join(lu, by = "pop_id")
  )
  return(x)
}

fit_stipm_smry <- fit_smry(fit_stipm) #takes a few...
fit_ar1_smry <- fit_smry(fit_ar1)

fit_ar1_smry$adult_pred |> print(n = 100)
fit_ar1_smry$adult_est |> print(n = 100)
tail(fit_ar1_smry$adult_est)
tail(fit_ar1_smry$adult_pred) 
#true...
identical(
  fit_ar1_smry$adult_est |> filter(year == 2019) |> select(mean)
  ,
  fit_ar1_smry$adult_pred |> select(mean)
  )

```

```{r playing_with_fit_ar1}
tbl_coho |> 
  #filter( !(pop_id %in% maybe_drop_popids)) |> 
  filter( pop_id %in% focal_popids) |> 
  select(year = `Calendar Year`, pop_id, pop, spwn, hvst) |> 
  pivot_longer(c(spwn, hvst), names_to = "var", values_to = "val") |> 
  ggplot(aes(year, val, fill = var, color = var)) +
  geom_col(position = "stack") +
  geom_ribbon(
    aes(x = year, ymin = `10%`, ymax = `90%`), inherit.aes = F,
    data = fit_ar1_summary$adult_est |> 
      filter( pop_id %in% focal_popids) |> 
      select(year, pop_id, pop, var, `10%`, `90%`),
    alpha = 0.3, color = "gold", fill = "gold") +
  geom_line(
    data = fit_ar1_summary$adult_est |> 
      filter( pop_id %in% focal_popids) |> 
      select(year, pop_id, pop, var, val = `50%`)) +
  scale_fill_grey(aesthetics = c("fill", "color")) +
  scale_x_continuous(n.breaks = 12,  guide = guide_axis(n.dodge = 2)) +
  scale_y_continuous("Return", labels = scales::comma) +
  facet_wrap(~pop_id + pop, scales = "free", labeller = label_wrap_gen(multi_line = F), ncol = 1)

```

```{r}
bind_rows(
  fit_ar1_smry$adult_est |> mutate(fit = "ar1")
  ,
  fit_stipm_smry$adult_est |> mutate(fit = "stipm")
  ) |> 
  filter(pop_id %in% focal_popids) |> 
  ggplot(aes(x = year, y = `50%`, ymin = `10%`, ymax = `90%`, color = fit, fill = fit)) +
  scale_y_continuous("Estimated adult return", labels = scales::comma) +
  wacolors::scale_fill_wa_d( aesthetics = c("fill", "color") ) +
  geom_ribbon(alpha = 0.5)
```


# sliding refits?

Basic approach of passing a data subset could be stretching (y1:yn) or sliding ([yn-window]:yn).

Generally prefer sliding, and arguably considerably weaker data earlier in the series, but could be good reasons to stretch here...

```{r}
library(slider)

focal_popids <- 35:36

#dummy example to rough out the pattern
foo <- tbl_coho_stan$rtrn |> 
  filter( pop_id %in% focal_popids) |> 
  select(year = `Calendar Year`, pop_id, pop, rtrn) |>
  group_by(pop_id, pop) |> 
  mutate(
    rtrn_mu5 = slide_dbl(rtrn, mean, .before = 5),
    lm_fit = slide(
      .x = cur_data(), #the subset of rows
      .f = ~lm(rtrn ~ year, data = .x), #the thing to do to them
      .before = 5, #how far back to look
      .complete = T
    ),
    lm_pred = lm_fit |> 
      map_dbl(~if_else(is.null(.x), NA_real_, last(.x$fitted.values)))
  ) |> 
  ungroup()

foo |> 
  select(year, pop_id, pop, rtrn, rtrn_mu5, lm_pred) |> 
  pivot_longer(cols = -c(year, pop_id, pop), names_to = "var", values_to = "val") |> 
  {\(x) 
  ggplot(x, aes(year, val, color = var)) +
  geom_line(data = filter(x, var != "rtrn")) +
  geom_point(data = filter(x, var == "rtrn")) + 
  scale_x_continuous(n.breaks = 10,  guide = guide_axis(n.dodge = 2)) +
  facet_wrap(~pop_id + pop, scales = "free", ncol = 1)
  }()
```


```{r}
#likely preferable to slide/stretch only for convenient dataset subsetting?


```




# compare skill