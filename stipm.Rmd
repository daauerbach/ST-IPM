---
title: "stipm"
author: "dan.auerbach@dfw.wa.gov modifying DeFilippo et al. 2021 in consultation with Thomas.Buehrens@dfw.wa.gov"
date: "`r Sys.Date()`"
editor_options: 
  chunk_output_type: console
output: 
  wdfwTemplates::wdfw_html_format

---

This script updates and extends the [original implementation](https://github.com/lukasdefilippo/ST-IPM) of [DeFilippo et al.'s (2021)](https://www.sciencedirect.com/science/article/pii/S0165783621001429) "Spatiotemporal Integrated Population Model" (ST-IPM) of Washington state natural origin coho (*O. kisutch*) returns, with initial application to annual preseason forecasts of Willapa Bay returning adults.

# setup

```{r setup, results = FALSE, warning = FALSE, message = FALSE}
knitr::opts_chunk$set(echo = TRUE, results = FALSE, warning = FALSE, message = FALSE)

library("tidyverse")
library("odbc"); library("DBI")
library("rstan")
options(mc.cores = 10) #12 on DA machine
rstan_options(auto_write = TRUE)
theme_set(theme_light())

f_orig <- "Coho_IPM_spatial_AR.r"

fp <- list(
  fram_file = "data/postseason_fram_spwn_hvst_ests.csv",
  coho_file = 'Coho data_3-30-20.csv',
  cwt_file = 'CWT_FRAM_Matches_complete20200303.csv',
  stream_file = 'Coho_KM_3.31.2020_2.csv'
  )

# # #lu_stock <- readxl::read_excel("stipm_pops_crosscheck.xlsx")
# # #lu_stock |> filter(FRAM_StockID != 13, FRAM_StockID != 43) |> pluck("FRAM_StockID") |> paste0(collapse = ",")
# # #drop FRAM StockID 13 and 43, original pop_ids 10 and 24
# fram_stocks <- c(105,93,89,45,51,55,75,81,61,23,149,63,107,115,111,157,97,135,153,101,69,1,85,139,131,127,145,11,17,59,35,29,117,161)

#can convert to csv etc. as needed
#may drop orig 10 and 24 from xlsx and reindex? and then drop filter...
pop_meta <- readxl::read_excel("pop_meta.xlsx") |>
  select(pop_id:hat) |>
  filter(StockID != 13, StockID != 43)

# maybe_drop_popids <- c(
# #these should probably go...
#   10, #not sure what this actually is...
#   24, #Pt Gamble, fixed BKFRAM input, not a pop
# #these maybe...
#   14, #Dungeness, recent estimate difficulties, but smolt ests
#   16, #Elwha, recent method changes and special habitat case 
#   18, #Green, relevance, recent estimate difficulties, but smolt ests
#   21, #LkWA, relevance/pop size
#   23 #Nooksack, proxy not an escp est, but smolt ests
#   )

```

# data

The analysis relies on per-stock escapement and harvest estimates compiled in post-season [coho FRAM](https://github.com/FRAMverse/fram_doc) runs as well as CWT-based marine survival estimates derived from RMIS, and smolt outmigrant estimates compiled by WDFW.

## FRAM postseason estimates of spawning escapement and harvest mortality

Coho FRAM tracks age 3 fish across 5 time steps corresponding to a calendar year. It includes unmarked and marked units of both natural and hatchery stocks. 

Data in the best available database extend to 1986, but all values prior to 1998 and some prior to 2004 are of unknown origin.

```{r fram_readers, eval=FALSE}
read_coho_backwards <- function (db, runs = NULL, stocks = NULL) {

  db_con <- DBI::dbConnect(drv = odbc::odbc(),
    .connection_string = paste0("Driver={Microsoft Access Driver (*.mdb, *.accdb)};DBQ=", db, ";"))

  #lazy, full table then reduce as specified
  bk <- dplyr::tbl(db_con, "BackwardsFRAM") |> dplyr::select(RunID, StockID, escp = TargetEscAge3)
  if (!is.null(runs)) { bk <- dplyr::filter(bk, RunID %in% runs) }
  if (!is.null(stocks)) { bk <- dplyr::filter(bk, StockID %in% stocks) }

  #associate metainfo and pull
  bk <- bk |> 
    dplyr::left_join(
      dplyr::tbl(db_con, "RunID") |>  dplyr::select(RunID, RunYear, RunName), 
      by = "RunID") |>
    dplyr::left_join(
      dplyr::tbl(db_con, "Stock") |> dplyr::filter(Species == "COHO") |> dplyr::select(StockID, StockLongName),
      by = "StockID") |>
    dplyr::collect() |> 
    dplyr::arrange(RunYear, StockID)

  DBI::dbDisconnect(db_con)
  
  return(bk)
}

read_coho_escapement <- function (db, runs = NULL, stocks = NULL) {

  db_con <- DBI::dbConnect(drv = odbc::odbc(),
    .connection_string = paste0("Driver={Microsoft Access Driver (*.mdb, *.accdb)};DBQ=", db, ";"))
  #coho is already only age 3 in TimeStep 5
  #lazy, full table then reduce as specified
  escp <- dplyr::tbl(db_con, "Escapement") |> dplyr::select(RunID, StockID, escp = Escapement)
  if (!is.null(runs)) { escp <- dplyr::filter(escp, RunID %in% runs) }
  if (!is.null(stocks)) { escp <- dplyr::filter(escp, StockID %in% stocks) }

  #associate metainfo and pull
  escp <- escp |> 
    dplyr::left_join(
      dplyr::tbl(db_con, "RunID") |>  dplyr::select(RunID, RunYear, RunName), 
      by = "RunID") |>
    dplyr::left_join(
      dplyr::tbl(db_con, "Stock") |> dplyr::filter(Species == "COHO") |> dplyr::select(StockID, StockLongName),
      by = "StockID") |>
    dplyr::collect() |> 
    dplyr::arrange(RunYear, StockID)

  DBI::dbDisconnect(db_con)
  
  return(escp)
}

read_coho_mort <- function (db, runs = NULL, stocks = NULL) {
  
  db_con <- DBI::dbConnect(drv = odbc::odbc(),
    .connection_string = paste0("Driver={Microsoft Access Driver (*.mdb, *.accdb)};DBQ=", db, ";"))
  
  #lazy, full table then reduce as specified
  m <- dplyr::tbl(db_con, "Mortality") |> dplyr::select(-PrimaryKey)
  if (!is.null(runs)) { m <- dplyr::filter(m, RunID %in% runs) }
  if (!is.null(stocks)) { m <- dplyr::filter(m, StockID %in% stocks) }

  #associate metainfo and pull
  m <- m |> 
    dplyr::left_join(
      dplyr::tbl(db_con, "RunID") |>  dplyr::select(RunID, RunYear, RunName), 
      by = "RunID") |>
    dplyr::left_join(
      dplyr::tbl(db_con, "Stock") |> dplyr::filter(Species == "COHO") |> dplyr::select(StockID, StockLongName),
      by = "StockID") |>
    dplyr::left_join(
      dplyr::tbl(db_con, "Fishery") |> dplyr::filter(Species == "COHO") |> dplyr::select(FisheryID, FisheryName), 
      by = "FisheryID") |> 
    dplyr::collect() |> 
    dplyr::arrange(RunYear, FisheryID, TimeStep, StockID)

  DBI::dbDisconnect(db_con)
  
  return(m)
}
```

```{r read_fram_tables, eval=FALSE}
#the relevant data are queried and re-exported as csv
#stays similar to original and allows greater reproducibility/portability
mdb <- "O:/code/coho_fram_validation/PSC_CoTC_PostSeason_CohoFRAMDB_thru2019_021021.mdb"
#appears to be a mysterious RunID 3 in the Escapement and Mortality tables but not RunID table...
#aggregate mortality across timesteps for all sources to "estimated total harvest related impacts"
fram <- full_join(
  read_coho_escapement(mdb, stocks = pop_meta$FRAM_StockID) |> 
    filter(!is.na(RunYear))
  ,
  read_coho_mort(mdb, stocks = pop_meta$FRAM_StockID) |>
    filter(!is.na(RunYear)) |> 
    mutate(mort = LandedCatch + NonRetention + Shaker + DropOff + MSFLandedCatch + MSFNonRetention + MSFShaker + MSFDropOff) |> 
    group_by(RunYear, StockID, StockLongName) |> 
    summarise(mort = sum(mort), .groups = "drop")
  ,
  by = c("RunYear", "StockID", "StockLongName")
  ) |> 
  select(year = RunYear, StockID, StockLongName, spwn = escp, hvst = mort)

#fram |> filter(StockID == 161) |> print(n = 100)

write_csv(fram, "data/postseason_fram_spwn_hvst_ests.csv")

```

## Smolt outmigrant estimates


## RMIS releases and recoveries for marine survival


## full dataset

```{r tbl_coho_full}
#moving towards deletion
#still working on smolt and CWT updates

drop_pop <- c("Queets", "Clearwater", 'Bell Creek', 'Johnson Creek', 'Jimmy Come Lately Creek',
              'Deep Creek', 'McDonald Creek', 'Siebert Creek', 'Salt Creek', 'Discovery Bay',
              'East Twin Creek', 'West Twin Creek', 'Northeast Hood Canal')

drop_cwt_surv <- c("Minter Crk H", "Baker H", "Satsop H") 

tbl_coho <- readr::read_csv(fp$coho_file) |> #1709x21
  mutate(
    pop = case_when(
      !is.na(`SaSI Population`) ~ `SaSI Population`,
      is.na(`SaSI Population`) & is.na(SubPopulation) ~ `Managment Unit (FRAM)`,
      is.na(`SaSI Population`) & !is.na(SubPopulation) ~ SubPopulation
    ),
    spwn = case_when(
      !is.na(`SaSI Population`) ~ `SASI Natural Origin Abundance`,
      is.na(`SaSI Population`) & is.na(SubPopulation) ~ `Age 3 Escapement (FRAM)`,
      is.na(`SaSI Population`) & !is.na(SubPopulation) ~ `SupPopulation Escapement`
    ),
    spwn = if_else(pop=="Discovery Bay", `SASI CompositeOrigin Abundance`, abs(spwn)) #corrects negative val for 2005 A12A Wild, orig L152
    ,
    hvst = spwn / (1/`Harvest (% FRAM)` - 1) 
  ) |> 
  filter( !(pop %in% drop_pop) ) |> 
  select(`Calendar Year`, `Smolt Abundance`, Latitude, Longitude, pop, spwn, hvst) |> 
  inner_join(
    readr::read_csv(fp$stream_file) |> 
      filter(Population != "", !is.na(Population)) |> #no NAs in the current csv, but left for now
      select(pop = Population, KM)
    ,
    by = "pop") |> 
  full_join(
    readr::read_csv(fp$cwt_file) |> 
      mutate(
        hat = if_else(stringr::str_detect(`Smolt Ocean Survival Population`, " H$"), 1, 0)
      ) |> 
      filter( !(`Smolt Ocean Survival Population` %in% drop_cwt_surv)) |> 
      select(pop = `Managment Unit (FRAM)`, `Calendar Year`, `Smolt Ocean Survival Population`, Fishery_Plus_Escapement, Release_No, hat)
    ,
    by = c("pop", "Calendar Year")) |> 
  filter(`Calendar Year` > 1985) |> 
  bind_rows(
    tibble(`Calendar Year` = 2013, yr = 28, pop = "Area 7-7A Independent Wild"),
    tibble(`Calendar Year` = 2004, yr = 19, pop = "Port Gamble Bay Wild"),
    tibble(`Calendar Year` = 2000:2001, yr = 15:16, pop = "Grays Harbor Miscellaneous Wild")
  ) |>
  left_join(
    bind_rows(
      tibble(pop = "Green River Wild", Long = -122.2145, Lat = 47.3519),
      tibble(pop = "Area 10E Miscellaneous Wild", Long = -122.8242, Lat = 47.5896)
    )
    , by = "pop") |>
  mutate(
    Longitude = if_else(is.na(Long), Longitude, Long), Long = NULL,
    Latitude = if_else(is.na(Lat), Latitude, Lat), Lat = NULL,
    Basin = if_else(Longitude < -123.80, 0, 1),
    `Smolt Abundance` = if_else(pop == "Puyallup River Wild", NA_real_, `Smolt Abundance`),
    hvst = if_else(stringr::str_detect(pop, "Quillayute River") & `Calendar Year` <= 1987, NA_real_, hvst),
    pop_id = as.numeric(factor(pop)),
    yr = `Calendar Year` - min(`Calendar Year`) + 1
  ) |> 
  rename(year = `Calendar Year`) |> 
  arrange(pop)

sf_coord <- tbl_coho |> 
  group_by(pop, pop_id) |> 
  summarise(long = median(Longitude, na.rm = T), lat = median(Latitude, na.rm = T), .groups = "drop") |> 
  sf::st_as_sf(coords = c("long", 'lat'), crs = sf::st_crs("+proj=longlat +datum=WGS84")) |> 
  sf::st_transform(crs = sf::st_crs("+proj=utm +zone=10T ellps=WGS84"))

```

```{r updating_full_dataset}

#left as reminder to recheck pop_id indexing
identical(sort(unique(left_join(pop_meta, read_csv(fp$fram_file), by = c("StockID", "StockLongName"))$pop_id)), 1:34)

coho_data_tbl <- pop_meta |> 
  left_join(read_csv(fp$fram_file), by = c("StockID", "StockLongName")) |>
  left_join(
    tbl_coho |> select(pop_id, year, smolt = `Smolt Abundance`, est_n_rec = Fishery_Plus_Escapement, est_n_rel = Release_No)
    ,
    by = c("pop_id", "year")
  )

coho_data_tbl |> filter(StockID == 161) |> print(n = 100)
```

## Prior preseason forecasts?

## LU export

Dump a file for discussion and review of included series.

```{r stipm_pops}
# tbl_coho |> 
#   group_by(pop_id, pop) |> 
#   summarise(
#     year_min = min(`Calendar Year`),
#     year_max = max(`Calendar Year`),
#     nobs_any = n(),
#     across(c(spwn, hvst, `Smolt Abundance`, Release_No), ~sum(!is.na(.))),
#     .groups = "drop"
#   ) |> #print(n = 50)
#   ##writexl::write_xlsx("stipm_pops_crosscheck.xlsx")

# #4 cases of missing KM/Lat/Long due to the orig sequence of dataset construction
# #where a few additional records are added after joining stream lengths
# #but expect to drop 7/7A and Pt Gamble anyway
# #also following orig approach on "median" of Lat/Long, though already uniform 
# #manually copied into working xlsx, leaving pop_id/pops to confirm matches before deleting
# tbl_coho |> 
#   filter(!is.na(KM)) |>
#   group_by(pop_id, pop) |> 
#   summarise(across(c(Longitude, Latitude, KM), median), .groups = "drop") |> 
#   write.table("clipboard", row.names = F)

# # add CWT marine survival info
# tbl_coho |> 
#   distinct(pop_id, pop,`Smolt Ocean Survival Population`, hat) |> 
#   filter(!is.na(hat)) |> 
#   select(pop_id, `Smolt Ocean Survival Population`, hat) |> 
#   right_join(tibble(pop_id = 1:36), by = "pop_id") |> arrange(pop_id) |> 
#   write.table("clipboard", row.names = F, na = "")
  

```


# fit stan

Begin by refitting stan to subsets of the data filtered by year in order to gauge "as applied" forecast skill.

For a 2022 forecast, made in Jan 2022, would have:
  - smolt abund: 2021
  - CWT rec/rel: 2020 (recoveries in 2020, from 2017 brood, 2019 release)
  - FRAM: complete 2019, compiling 2020
    - but (at least for WB) have 2020 and maybe prelim 2021 escapements and non-sport catch
    
So need to supply for targeting year y:
  - STIPM: smolt[y-1], MS[y-2], spwn[y-2]+hvst[y-2] or spwn[y-3]+hvst[y-3]
  - AR1: spwn[y-2]+hvst[y-2] or spwn[y-3]+hvst[y-3] 

## wrappers

```{r stan_data_filter}
#trim years then declare separate intermediaries
#lags allow for flexible OAT configurations with additional trimming
#but can be zeroed to allow all available data
#for a 2022 forecast in adult_pred vectors from stan
#year_max is 2021, s.t. firmly available postseason FRAM is 2019 
stan_data_filter <- function(
  full, #complete dataset
  year_min, #starting anchor year
  year_max, #year before adult_pred, last year of adult_est
  lag_smolt = 0, #n-extra-years trimmed from smolt abundances 
  lag_MS = 1, #n-extra-years trimmed from release and recovery data
  lag_spwn = 2, #n-extra-years trimmed from FRAM escapement
  lag_hvst = 2 #n-extra-years trimmed from FRAM harvest
  ){
  
  full_ymin_ymax = filter(full, between(year, year_min, year_max)) |> 
    mutate(yr = year - min(year) + 1)
  
  stan_data = list(
    y_min_max = year_min:year_max,
    smolt = filter(full_ymin_ymax, !is.na(`Smolt Abundance`), year <= year_max - lag_smolt),
    MS = filter(full_ymin_ymax, !is.na(Release_No), year <= year_max - lag_MS),
    spwn = filter(full_ymin_ymax, !is.na(spwn), year <= year_max - lag_spwn),
    hvst = filter(full_ymin_ymax, !is.na(hvst), year <= year_max - lag_hvst) |> 
      mutate(hvst = abs(hvst)),
    rtrn = full_ymin_ymax |> 
      mutate(rtrn = spwn + abs(hvst)) |>
      filter(!is.na(rtrn), year <= year_max - max(c(lag_spwn, lag_hvst)))
  )
  
  return(stan_data)
}

```

Note this uses `tbl_coho` for the "full" number of populations, which should generally equal the number with spwn+hvst values from FRAM. Could hard-code a numeric value after settling on a final population set (e.g., 34).

Given the OAT focus on a single year of prediction, could add an AR1 specific summary extraction function to get full series of estimates or other output...

```{r ar1_functions}
stan_ar1 <- function(stan_data, n_iter = 200, n_chain = 2){
  #note following orig naming convention where "tot" refers to "total return" = spwn + hvst, as estimated from FRAM
  stan_fit <- stan(
    file = 'LD_coho_forecast_AR_ind_2.stan',
    iter = n_iter, chains = n_chain, thin = 1, seed = 222,
    control = list(adapt_delta = 0.99, max_treedepth = 10.25),
    data = list(
      n_year = length(stan_data$y_min_max) + 1, #sets year of adult_pred and year-dim of adult_est 
      n_pop = length(unique(tbl_coho$pop_id)), #number of populations in full dataset (should generally equal n_pop_tot with)
      n_pop_tot = length(unique(stan_data$rtrn$pop_id)), #Number of populations with return data
      pop_tot = unique(stan_data$rtrn$pop_id), #Which populations possess return data
      n_tot = length(stan_data$rtrn$rtrn), #Length of the return data vectors
      tot_dat = stan_data$rtrn$rtrn,  #Vectors of all return data across all populations
      tot_true = stan_data$rtrn$yr, #Vectors of the indices identifying which years are those with non-NA data for the return data
      #Paired vectors of slice points indicating the beginning, and end of the data for a particular population
      slice_tot_start = stan_data$rtrn |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
      slice_tot_end = stan_data$rtrn |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid")
    )
  )
  
  return(stan_fit)
}

```

Could get `stream_dist` from LU or sf_coord? Other fixed values here? As above, could avoid call to global `tbl_coho` for n_pop

```{r stipm_functions}
stan_stipm <- function(stan_data, n_iter = 200, n_chain = 2){
  #note n_year does not include "+1" of AR1 since adult_pred is calc'd separately as
  # smolt[n_year]*surv[n_year], thereby giving adult run size (spwn+hvst) in n_year+1
  stan_fit <- stan(
    file = 'LD_coho_forecast_6_2_4.stan', 
    iter = n_iter, chains = n_chain, thin = 1, seed = 222,
    control = list(adapt_delta = 0.99, max_treedepth = 10.25),
    data = list(
      n_year = length(stan_data$y_min_max), 
      n_pop = length(unique(tbl_coho$pop_id)), #number of populations in full dataset
      u = matrix(1, nrow = 1, ncol = length(unique(stan_data$spwn$pop_id))),
      dist = units::drop_units(sf::st_distance(sf_coord)/10000), #values are identical
      
      pop_smolt = unique(stan_data$smolt$pop_id), #pop_ids with smolt data 
      n_pop_smolt = length(unique(stan_data$smolt$pop_id)),
      smolt_true = stan_data$smolt$yr,
      smolt_dat = stan_data$smolt$`Smolt Abundance`,
      n_smolt = nrow(stan_data$smolt),
      
      pop_esc = unique(stan_data$spwn$pop_id),  # pop_ids with escapement data
      n_pop_esc = length(unique(stan_data$spwn$pop_id)),
      esc_true = stan_data$spwn$yr,
      esc_dat = stan_data$spwn$spwn,
      n_esc = nrow(stan_data$spwn),
      
      pop_catch = unique(stan_data$hvst$pop_id), #pop_ids with harvest data
      n_pop_catch = length(unique(stan_data$hvst$pop_id)),
      harvest_true = stan_data$hvst$yr,
      harvest_dat = stan_data$hvst$hvst,
      n_harvest = nrow(stan_data$hvst),
      
      pop_MS = unique(stan_data$MS$pop_id), #pop_ids with marine survival data
      n_pop_MS = length(unique(stan_data$MS$pop_id)),
      MS_true = stan_data$MS$yr, #orig uses Fishery_Plus_Escapement rather than Release_No to filter...
      MS_dat_x = stan_data$MS$Fishery_Plus_Escapement |> round(), #stan expects integer...
      MS_dat_N = stan_data$MS$Release_No,
      n_MS = nrow(stan_data$MS),
      
      stream_dist = stan_data$spwn |> distinct(pop, KM) |> pluck("KM"),
      
      sigma_esc = 0.2,
      
      n_hatchery = filter(stan_data$MS, hat == 1) |> distinct(pop_id) |> nrow(),
      hatchery = distinct(stan_data$MS, pop_id, pop, hat) |> 
        mutate(hat_id = if_else(hat > 0, row_number(), NA_integer_)) |> 
        filter(!is.na(hat_id)) |> pluck("hat_id"),
      wild = distinct(stan_data$MS, pop_id, pop, hat) |> 
        mutate(hat_id = if_else(hat < 1, row_number(), NA_integer_)) |> 
        filter(!is.na(hat_id)) |> pluck("hat_id"), 
      
      slice_smolt_start = stan_data$smolt |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
      slice_smolt_end = stan_data$smolt |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
      
      slice_esc_start = stan_data$spwn |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
      slice_esc_end = stan_data$spwn |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
      
      slice_harvest_start = stan_data$hvst |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
      slice_harvest_end = stan_data$hvst |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
      
      slice_MS_start = stan_data$MS |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
      slice_MS_end = stan_data$MS |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid")
    )
  )
  return(stan_fit)
}
```

```{r oat}
p <- c(0.1, 0.5, 0.9)
lu <- tbl_coho |> distinct(pop_id, pop)
oat_year_min <- 1998
oat_years_max <- 2009:2019

oat <- set_names(c(2014)) |> 
  map(function(x) {
    print(x)
    stan_data_list <- stan_data_filter(tbl_coho, year_min = oat_year_min, year_max = x) #with defaults
    print(stan_data_list$y_min_max)
    print(range(stan_data_list$smolt$year))
    print(range(stan_data_list$MS$year))
    print(range(stan_data_list$spwn$year))

    stan_data_list <- stan_data_filter(tbl_coho, year_min = oat_year_min, year_max = x, lag_spwn = 1, lag_hvst = 1) #with "compiling" FRAM data
    print(stan_data_list$y_min_max)
    print(range(stan_data_list$smolt$year))
    print(range(stan_data_list$MS$year))
    print(range(stan_data_list$spwn$year))

    # fit_ar1 <- stan_ar1(stan_data = stan_data_list, n_iter = 200, n_chain = 2)
    # fit_ar1_pred <- summary(fit_ar1, pars = "adult_pred", probs = p)$summary |> 
    #   as.data.frame() |> rownames_to_column("stan_out") |> tibble() |> 
    #   mutate(
    #     var = str_extract(stan_out, "[a-z]+[:punct:][a-z]+"),
    #     pop_id = as.numeric(str_extract(stan_out, "[0-9]+")),
    #     year = last(stan_data_list$y_min_max) + 1 #should be x+1
    #   ) |> 
    #   left_join(lu, by = "pop_id")
    
    # fit_stipm <- stan_stipm(stan_data = stan_data_list, n_iter = 200, n_chain = 2)
    # fit_stipm_pred <- summary(fit_stipm, pars = "adult_pred", probs = p)$summary |> 
    #   as.data.frame() |> rownames_to_column("stan_out") |> tibble() |> 
    #   mutate(
    #     var = str_extract(stan_out, "[a-z]+[:punct:][a-z]+"),
    #     pop_id = as.numeric(str_extract(stan_out, "[0-9]+")),
    #     year = last(stan_data_list$y_min_max) + 1 #should be x+1
    #   ) |> 
    #   left_join(lu, by = "pop_id")
    
    # return(fit_ar1_pred)
    # return(fit_stipm_pred)
    
  })



left_join(
bind_rows(oat)
,
tbl_coho |> mutate(rtrn = spwn + abs(hvst)) |> select(year, pop_id, rtrn)
,
by = c("year", "pop_id")
) |> 
  select(year, pop_id, pop, rtrn, `10%`:`90%`) |> 
  mutate(
    ae = abs(`50%` - rtrn),
    ae_log = abs(log(`50%`) - log(rtrn))
  ) |> 
  filter(pop_id == 36)


```


# Can delete soon


```{r wrapper_stan_stipm}
stan_stipm <- function(full, year_min, year_max, n_iter = 200, n_chain = 2){
  #trim years
  full_ymin_ymax = filter(full, between(year, year_min, year_max)) |> 
    mutate(yr = year - min(year) + 1)
  
  #declare separate intermediaries
  stan_data = list(
      smolt = filter(full_ymin_ymax, !is.na(`Smolt Abundance`)),
      esc = filter(full_ymin_ymax, !is.na(spwn)),
      catch = filter(full_ymin_ymax, !is.na(hvst)) |> mutate(hvst = abs(hvst)),
      MS = filter(full_ymin_ymax, !is.na(Release_No)), #note both "Release_No" and "Fishery_Plus_Escapement" are used in orig, setting up potential divergence conflict
      rtrn = full_ymin_ymax |> 
        mutate(rtrn = spwn + abs(hvst)) |> #same fix as catch
        filter(!is.na(rtrn))
    )
    
  stan_fit <- stan(
    file = 'LD_coho_forecast_6_2_4.stan', 
    iter = n_iter, chains = n_chain, thin = 1, seed = 222,
    control = list(adapt_delta = 0.99, max_treedepth = 10.25),
    data = list(
      n_year = length(year_min:year_max), 
      n_pop = length(unique(stan_data$esc$pop_id)),
      u = matrix(1, nrow = 1, ncol = length(unique(stan_data$esc$pop_id))),
      dist = units::drop_units(sf::st_distance(sf_coord)/10000), #values are identical
      
      pop_smolt = unique(stan_data$smolt$pop_id), #pop_ids with smolt data 
      n_pop_smolt = length(unique(stan_data$smolt$pop_id)),
      smolt_true = stan_data$smolt$yr,
      smolt_dat = stan_data$smolt$`Smolt Abundance`,
      n_smolt = nrow(stan_data$smolt),
      
      pop_esc = unique(stan_data$esc$pop_id),  # pop_ids with escapement data
      n_pop_esc = length(unique(stan_data$esc$pop_id)),
      esc_true = stan_data$esc$yr,
      esc_dat = stan_data$esc$spwn,
      n_esc = nrow(stan_data$esc),
      
      pop_catch = unique(stan_data$catch$pop_id), #pop_ids with harvest data
      n_pop_catch = length(unique(stan_data$catch$pop_id)),
      harvest_true = stan_data$catch$yr,
      harvest_dat = stan_data$catch$hvst,
      n_harvest = nrow(stan_data$catch),
      
      pop_MS = unique(stan_data$MS$pop_id), #pop_ids with marine survival data
      n_pop_MS = length(unique(stan_data$MS$pop_id)),
      MS_true = stan_data$MS$yr, #orig uses Fishery_Plus_Escapement rather than Release_No to filter...
      MS_dat_x = stan_data$MS$Fishery_Plus_Escapement |> round(), #stan expects integer...
      MS_dat_N = stan_data$MS$Release_No,
      n_MS = nrow(stan_data$MS),
      
      stream_dist = stan_data$esc |> distinct(pop, KM) |> pluck("KM"), #previously taking mean, but values should be identical at this stage
      
      sigma_esc = 0.2,
      
      n_hatchery = filter(stan_data$MS, hat == 1) |> distinct(pop_id) |> nrow(),
      hatchery = distinct(stan_data$MS, pop_id, pop, hat) |> 
        mutate(hat_id = if_else(hat > 0, row_number(), NA_integer_)) |> 
        filter(!is.na(hat_id)) |> pluck("hat_id"),
      wild = distinct(stan_data$MS, pop_id, pop, hat) |> 
        mutate(hat_id = if_else(hat < 1, row_number(), NA_integer_)) |> 
        filter(!is.na(hat_id)) |> pluck("hat_id"), 
      
      slice_smolt_start = stan_data$smolt |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
      slice_smolt_end = stan_data$smolt |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
      
      slice_esc_start = stan_data$esc |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
      slice_esc_end = stan_data$esc |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
      
      slice_harvest_start = stan_data$catch |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
      slice_harvest_end = stan_data$catch |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
      
      slice_MS_start = stan_data$MS |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
      slice_MS_end = stan_data$MS |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid")
    )
  )
  return(stan_fit)
}

```

```{r wrapper_stan_ar1}
stan_ar1 <- function(full, year_min, year_max, n_iter = 200, n_chain = 2){
  #trim years
  full_ymin_ymax = filter(full, between(year, year_min, year_max)) |> 
    mutate(yr = year - min(year) + 1)
  
  #declare separate intermediaries
  #only actually need `rtrn` in AR1 context?
  stan_data = list(
      smolt = filter(full_ymin_ymax, !is.na(`Smolt Abundance`)),
      esc = filter(full_ymin_ymax, !is.na(spwn)),
      catch = filter(full_ymin_ymax, !is.na(hvst)) |> mutate(hvst = abs(hvst)),
      MS = filter(full_ymin_ymax, !is.na(Release_No)), #note both "Release_No" and "Fishery_Plus_Escapement" are used in orig, setting up potential divergence conflict
      rtrn = full_ymin_ymax |> 
        mutate(rtrn = spwn + abs(hvst)) |> #same fix as catch
        filter(!is.na(rtrn))
    )
    
  stan_fit <- stan(
    file = 'LD_coho_forecast_AR_ind_2.stan',
    iter = n_iter, chains = n_chain, thin = 1, seed = 222,
    control = list(adapt_delta = 0.99, max_treedepth = 10.25),
    data = list(
      #Number of years (total, includes several missing years for some stocks)
      n_year = length(year_min:year_max) + 1, 
      #Number of total populations    
      n_pop = length(unique(stan_data$rtrn$pop_id)),
      #Number of populations with return data
      n_pop_tot = length(unique(stan_data$rtrn$pop_id)),
      #Which populations possess return data
      pop_tot = unique(stan_data$rtrn$pop_id),
      #Length of the return data vectors
      n_tot = nrow(stan_data$rtrn), #length(tot_dat)
      #Vectors of all return data across all populations
      tot_dat = stan_data$rtrn$rtrn,
      #Vectors of the indices identifying which years are those with non-NA data for the return data
      tot_true = stan_data$rtrn$yr,
      #Paired vectors of slice points indicating the beginning, and end of the data for a particular population
      slice_tot_start = stan_data$rtrn |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
      slice_tot_end = stan_data$rtrn |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid")
    )
  )
  
  return(stan_fit)
}
```

Filtering with the `year_min` argument requires resetting the `yr` indexing, which in turn requires that `year_min` is also passed to summary function to properly back convert to year.

 - STIPM: 
  - adult_est is spawning escapement of (return) year, through n_year
  - adult_pred is smolt[n_year]*surv[n_year] for adult run size (spwn+hvst) n_year+1
 - AR1:
  - adult_est and adult_pred are run size (spwn+hvst)

```{r fit_smry_function}
#TB suggest appending "adult_pred" as the next year "forecast" in STIPM..?
#little wrapper to mod later, revise reliance on global `tbl_coho` for pop string lu
#only really need the "merged chains" output from summary() if continuing this route?

fit_smry <- function(
  fit_obj, 
  p = c(0.1, 0.5, 0.9),
  year_min = min(tbl_coho$year),
  lu = tbl_coho |> distinct(pop_id, pop)
  ) {
  x <- list(
    #adult_est is [year, pop] indexed
    adult_est = summary(fit_obj, pars = "adult_est", probs = p)$summary |> 
      as.data.frame() |> rownames_to_column("stan_out") |> tibble() |> 
      mutate(
        var = str_extract(stan_out, "[a-z]+[:punct:][a-z]+"),
        year = (year_min - 1) + as.numeric(str_extract(stan_out, "[0-9]{1,2}")),
        pop_id = str_remove(stan_out, var) |> str_split(",") |> map_dbl( ~str_extract(.x[2], "[0-9]+") |> as.numeric())
      ) |> 
      left_join(lu, by = "pop_id")
    ,
    #adult_pred is pop indexed only
    adult_pred = summary(fit_obj, pars = "adult_pred", probs = p)$summary |> 
      as.data.frame() |> rownames_to_column("stan_out") |> tibble() |> 
      mutate(
        var = str_extract(stan_out, "[a-z]+[:punct:][a-z]+"),
        pop_id = as.numeric(str_extract(stan_out, "[0-9]+"))
      ) |> 
      left_join(lu, by = "pop_id")
  )
  return(x)
}
```

## testing

```{r test_converge_start_1998}
## need to pull out PtGamble & 7/7A before pop_id assigned to avoid confusing stan indexing...
# tbl_coho <- filter(tbl_coho, !str_detect(pop, "Gamble|7-7A"))
# sf_coord <- filter(sf_coord, !str_detect(pop, "Gamble|7-7A")) 

Sys.time() #19:50
fit_stipm_86_17 <- stan_stipm(full = tbl_coho, year_min = 1986, year_max = 2017, n_iter = 2000, n_chain = 4)
fit_stipm_86_17_smry <- fit_smry(fit_stipm_86_17, year_min = 1986)
Sys.time() #22:15

Sys.time() #22:15
fit_stipm_98_17 <- stan_stipm(full = tbl_coho, year_min = 1998, year_max = 2017, n_iter = 2000, n_chain = 4)
fit_stipm_98_17_smry <- fit_smry(fit_stipm_98_17, year_min = 1998)
Sys.time() #23:55

fit_ar1_86_17 <- stan_ar1(full = tbl_coho, year_min = 1986, year_max = 2017)
fit_ar1_86_17_smry <- fit_smry(fit_ar1_86_17, year_min = 1986)

fit_ar1_98_17 <- stan_ar1(full = tbl_coho, year_min = 1998, year_max = 2017)
fit_ar1_98_17_smry <- fit_smry(fit_ar1_98_17, year_min = 1998)

bind_rows(
  fit_ar1_86_17_smry$adult_est |> mutate(fit = "1986"),
  fit_ar1_98_17_smry$adult_est |> mutate(fit = "1998")
) |> 
  filter(pop_id == 36) |> 
  ggplot(aes(x = year, fill = fit, color = fit)) +
  scale_y_continuous("Estimated val", labels = scales::comma) +
  scale_fill_brewer(type = "qual", aesthetics = c("fill", "color") ) +
  geom_ribbon(aes(ymin = `10%`, ymax = `90%`), alpha = 0.2) + 
  geom_line(aes(y = `50%`)) +
  geom_point(
    data = tbl_coho |> mutate(fit = "obs", rtrn = spwn+hvst) |> filter(pop_id == 36) |> select(fit, year, pop, pop_id, rtrn),
    aes(y = rtrn),
    inherit.aes = T) +
  facet_wrap(~pop)

# #currently incommensurate - AR1 returning spwn+hvst, STIPM just spwn...
# bind_rows(
#   fit_stipm_86_17_smry$adult_est |> mutate(fit = "stipm")
#   ,
#   fit_ar1_86_17_smry$adult_est |> mutate(fit = "ar1")
# ) |> 
#   filter(pop_id == 36) |> 
#   ggplot(aes(x = year, fill = fit, color = fit)) +
#   scale_y_continuous("Estimated val", labels = scales::comma) +
#   scale_fill_brewer(type = "qual", aesthetics = c("fill", "color") ) +
#   geom_ribbon(aes(ymin = `10%`, ymax = `90%`), alpha = 0.2) + 
#   geom_line(aes(y = `50%`)) +
#   geom_point(
#     data = tbl_coho |> mutate(fit = "obs") |> filter(pop_id == 36) |> select(fit, year, pop, pop_id, spwn),
#     aes(y = spwn),
#     inherit.aes = T) +
#   facet_wrap(~pop)

bind_rows(
  # fit_ar1_86_17_smry$adult_est |> mutate(fit = "1986"),
  # fit_ar1_98_17_smry$adult_est |> mutate(fit = "1998")
  fit_stipm_86_17_smry$adult_est |> mutate(fit = "1986"),
  fit_stipm_98_17_smry$adult_est |> mutate(fit = "1998")
  ) |>
  filter(between(year, 1998, 2017)) |> 
  select(fit, year, pop_id, pop, med = `50%`) |> 
  left_join(
    #tbl_coho |> mutate(obs_rtrn = spwn+hvst) |> select(year, pop_id, pop, obs_rtrn),
    tbl_coho |> mutate(obs_spwn = spwn) |> select(year, pop_id, pop, obs_spwn),
    by = c("year", "pop_id", "pop")
  ) |> 
  mutate(
    #ae = abs(med - obs_rtrn)
    ae = abs(log(med) - log(obs_spwn))
    ) |> 
  group_by(fit, pop_id, pop) |> 
  summarise(across(starts_with("ae"), ~mean(.)), .groups = "drop") |> 
  #pivot_wider(names_from = fit, values_from = ae) |> print(n = 100)
  group_by(fit) |> summarise(across(starts_with("ae"), list(med = ~median(., na.rm = T), sd = ~sd(., na.rm = T))), .groups = "drop")


fit_ar1_86_17_smry$adult_est |> filter(pop_id == 36, year == 2018)
fit_ar1_86_17_smry$adult_pred |> filter(pop_id == 36) #same, 2018
fit_stipm_86_17_smry$adult_pred |> filter(pop_id == 36) #also 2018?
tbl_coho |> filter(pop_id == 36, year > 2009)


```

## stretch OAT

```{r revised_stretching_ar1}
oat_year_min <- 1998
oat_years_max <- 2009:2019

#want to do as a walk() or for() with in-loop dump outs? warnings/diagnostics carried through in returned object?
#any way to reduce the memory claim? looks like AR1 is ~3-5min/yr for 1K4
Sys.time() #18:12
oat_ar1 <- set_names(oat_years_max) |> 
  map(function(x) {
    print(x)
    fit <- stan_ar1(full = tbl_coho, year_min = oat_year_min, year_max = x, n_iter = 1000, n_chain = 4)
    return(fit)
    })
Sys.time() #18:55

oat_ar1_smry <- oat_ar1 |> #781mb to 1.4mb
  map(.f = fit_smry, year_min = oat_year_min)


```



Here we declare a few intermediates to reduce repeated filter calls around different data elements (reaching the vectors with no missing data required by stan).

```{r tbl_coho_stan}
#wrapper to incrementally (re)build stan-ready intermediary objects
tbl_coho_filter_to_stan <- function(full, year_min = 1986, year_max = 2018){
  full = full |> 
    filter(between(year, year_min, year_max)) |> 
    mutate(yr = year - min(year) + 1)
  list(
    smolt = filter(full, !is.na(`Smolt Abundance`)),
    esc = filter(full, !is.na(spwn)),
    #mutate overrides the single bad harvest val related to neg escapement/ER>1 issue above
    catch = filter(full, !is.na(hvst)) |> mutate(hvst = abs(hvst)),
    MS = filter(full, !is.na(Release_No)), #note both "Release_No" and "Fishery_Plus_Escapement" are used in orig, setting up potential divergence conflict
    rtrn = full |> mutate(rtrn = spwn + abs(hvst)) |> #same fix as catch
      filter(!is.na(rtrn))
  )
}

tbl_coho_stan <- tbl_coho_filter_to_stan(tbl_coho, year_min = 1986, year_max = 2018) #as original
```

```{r revised_stan_fit_stipm}
# #dropping iter for testing but otherwise using original function default control args on L456-7
# #actual fit on L1272 uses 20K iter and 5 chains but otherwise same
# 
# #would prefer better within-list naming convention, but for now left as-is other than reorg around data types
# fit_stipm <- stan(
#   file = 'LD_coho_forecast_6_2_4.stan', 
#   iter = 200,
#   chains = 4,
#   control = list(
#     adapt_delta = 0.99,
#     max_treedepth = 10.25
#     ),
#   thin = 1,
#   seed = 222,
#   data = list(
#     n_year = length(unique(tbl_coho$year)), #orig includes NA with 1986:2018
#     n_pop = length(unique(tbl_coho$pop_id)), #orig includes 8 additional IDs for plotting 'Name' only (i.e., no data)
#     u = matrix(1, nrow = 1, ncol = length(unique(tbl_coho$pop_id))),
#     dist = units::drop_units(sf::st_distance(sf_coord)/10000), #values are identical
#     #could also: as.matrix(dist(sf::st_coordinates(coord), 'euclidean', diag = TRUE, upper = TRUE)/10000)
#     
#     pop_smolt = unique(tbl_coho_stan$smolt$pop_id), #pop_ids with smolt data 
#     n_pop_smolt = length(unique(tbl_coho_stan$smolt$pop_id)),
#     smolt_true = tbl_coho_stan$smolt$yr,
#     smolt_dat = tbl_coho_stan$smolt$`Smolt Abundance`,
#     n_smolt = nrow(tbl_coho_stan$smolt),
#     
#     pop_esc = unique(tbl_coho_stan$esc$pop_id),  # pop_ids with escapement data
#     n_pop_esc = length(unique(tbl_coho_stan$esc$pop_id)),
#     esc_true = tbl_coho_stan$esc$yr,
#     esc_dat = tbl_coho_stan$esc$spwn,
#     n_esc = nrow(tbl_coho_stan$esc),
#     
#     pop_catch = unique(tbl_coho_stan$catch$pop_id), #pop_ids with harvest data
#     n_pop_catch = length(unique(tbl_coho_stan$catch$pop_id)),
#     harvest_true = tbl_coho_stan$catch$yr,
#     harvest_dat = tbl_coho_stan$catch$hvst,
#     n_harvest = nrow(tbl_coho_stan$catch),
#     
#     pop_MS = unique(tbl_coho_stan$MS$pop_id), #pop_ids with marine survival data
#     n_pop_MS = length(unique(tbl_coho_stan$MS$pop_id)),
#     MS_true = tbl_coho_stan$MS$yr, #orig uses Fishery_Plus_Escapement rather than Release_No to filter...
#     MS_dat_x = tbl_coho_stan$MS$Fishery_Plus_Escapement |> round(), #stan expects integer...
#     MS_dat_N = tbl_coho_stan$MS$Release_No,
#     n_MS = nrow(tbl_coho_stan$MS),
#     
#     stream_dist = tbl_coho |> group_by(pop) |> summarise(d = mean(KM, na.rm = T), .groups = "drop") |> select(d) |> unlist() |> as.numeric(),
#     
#     #elements called "sigma_catch" and "sigma_smolt" are commented out
#     #this is a passed arg in the orig exec_fun()
#     sigma_esc = 0.2,
#     
#     n_hatchery = filter(tbl_coho, hat == 1) |> distinct(pop_id) |> nrow(),
#     #NOT WHAT WE WANT: hatchery = filter(tbl_coho_stan$MS, hat == 1) |> distinct(pop_id) |> pluck("pop_id"),
#     hatchery = distinct(tbl_coho_stan$MS, pop_id, pop, hat) |> 
#       mutate(hat_id = if_else(hat > 0, row_number(), NA_integer_)) |> 
#       filter(!is.na(hat_id)) |> pluck("hat_id"),
#     wild = distinct(tbl_coho_stan$MS, pop_id, pop, hat) |> 
#       mutate(hat_id = if_else(hat < 1, row_number(), NA_integer_)) |> 
#       filter(!is.na(hat_id)) |> pluck("hat_id"), 
#  
#     slice_smolt_start = tbl_coho_stan$smolt |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
#     slice_smolt_end = tbl_coho_stan$smolt |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
#     
#     slice_esc_start = tbl_coho_stan$esc |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
#     slice_esc_end = tbl_coho_stan$esc |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
#     
#     slice_harvest_start = tbl_coho_stan$catch |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
#     slice_harvest_end = tbl_coho_stan$catch |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
#     
#     slice_MS_start = tbl_coho_stan$MS |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
#     slice_MS_end = tbl_coho_stan$MS |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid")
#   )
# )

```

```{r stan_fit_ar1}
# # #	only a few population-years missing estimates
# # tbl_coho_stan$rtrn |> count(pop_id) |> print(n=50)
#   
# #why is n_year "+1" here?
# #"_tot" refers to "total return"
# # a "n_year_true_tot" gets declared but not passed and not expected by AR stan
# fit_ar1 <- stan(
#   file = 'LD_coho_forecast_AR_ind_2.stan',
#   iter = 200,
#   chains = 2,
#   control = list(
#     adapt_delta = 0.99,
#     max_treedepth = 10.25
#   ),
#   thin = 1,
#   seed = 222,
#   data = list(
#     #Number of years (total, includes several missing years for some stocks)
#     n_year = length(unique(tbl_coho$year)) + 1,
#     #Number of total populations    
#     n_pop = length(unique(tbl_coho$pop_id)),
#     #Number of populations with return data
#     n_pop_tot = length(unique(tbl_coho_stan$rtrn$pop_id)),
#     #Which populations possess return data
#     pop_tot = unique(tbl_coho_stan$rtrn$pop_id),
#     #Length of the return data vectors
#     n_tot = nrow(tbl_coho_stan$rtrn), #length(tot_dat)
#     #Vectors of all return data across all populations
#     tot_dat = tbl_coho_stan$rtrn$rtrn,
#     #Vectors of the indices identifying which years are those with non-NA data for the return data
#     tot_true = tbl_coho_stan$rtrn$yr,
#     #Paired vectors of slice points indicating the beginning, and end of the data for a particular population
#     slice_tot_start = tbl_coho_stan$rtrn |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
#     slice_tot_end = tbl_coho_stan$rtrn |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid")
#     )
#   )

```

```{r try_tidybayes, eval=FALSE}
#could further examine library(tidybayes)? and/or library(bayesplot)?
library(tidybayes)

fit_ar1 |> 
  recover_types(tbl_coho_stan$rtrn) |> #not doing much since pops already numerically indexed
  spread_draws(adult_est[y,i]) |> #TMI?
  median_qi()
```

```{r fit_smry_initial_testing}
fit_stipm_smry <- fit_smry(fit_stipm) #takes a few...
fit_ar1_smry <- fit_smry(fit_ar1)

fit_ar1_smry$adult_pred |> print(n = 100)
fit_ar1_smry$adult_est |> print(n = 100)
tail(fit_ar1_smry$adult_est)
tail(fit_ar1_smry$adult_pred) 
#true...
identical(
  fit_ar1_smry$adult_est |> filter(year == 2019) |> select(mean)
  ,
  fit_ar1_smry$adult_pred |> select(mean)
  )

#not true; no 2019
identical(
  fit_stipm_smry$adult_est |> filter(year == 2018) |> select(mean)
  ,
  fit_stipm_smry$adult_pred |> select(mean)
  )
identical(
  fit_stipm_smry$adult_est |> filter(year == 2017) |> select(mean)
  ,
  fit_stipm_smry$adult_pred |> select(mean)
  )

```

```{r playing_with_fit_ar1}
tbl_coho |> 
  #filter( !(pop_id %in% maybe_drop_popids)) |> 
  filter( pop_id %in% focal_popids) |> 
  select(year = year, pop_id, pop, spwn, hvst) |> 
  pivot_longer(c(spwn, hvst), names_to = "var", values_to = "val") |> 
  ggplot(aes(year, val, fill = var, color = var)) +
  geom_col(position = "stack") +
  geom_ribbon(
    aes(x = year, ymin = `10%`, ymax = `90%`), inherit.aes = F,
    data = fit_ar1_smry$adult_est |> 
      filter( pop_id %in% focal_popids) |> 
      select(year, pop_id, pop, var, `10%`, `90%`),
    alpha = 0.3, color = "gold", fill = "gold") +
  geom_line(
    data = fit_ar1_smry$adult_est |> 
      filter( pop_id %in% focal_popids) |> 
      select(year, pop_id, pop, var, val = `50%`)) +
  scale_fill_grey(aesthetics = c("fill", "color")) +
  scale_x_continuous(n.breaks = 12,  guide = guide_axis(n.dodge = 2)) +
  scale_y_continuous("Return", labels = scales::comma) +
  facet_wrap(~pop_id + pop, scales = "free", labeller = label_wrap_gen(multi_line = F), ncol = 1)

```

```{r toy_ribbons}
bind_rows(
  fit_ar1_smry$adult_est |> mutate(fit = "ar1")
  ,
  fit_stipm_smry$adult_est |> mutate(fit = "stipm")
  ) |> 
  filter(pop_id %in% focal_popids) |> 
  ggplot(aes(x = year, y = `50%`, ymin = `10%`, ymax = `90%`, color = fit, fill = fit)) +
  scale_y_continuous("Estimated adult return", labels = scales::comma) +
  wacolors::scale_fill_wa_d( aesthetics = c("fill", "color") ) +
  geom_ribbon(alpha = 0.5)
```


## one-ahead prediction

```{r demo_stretch_allpops}
library(slider)

#stretching: before = Inf, so cumulative
foo <- tbl_coho_stan$rtrn |> 
  #filter( pop_id %in% focal_popids) |> 
  select(year, pop_id, pop, rtrn) |>
  group_by(pop_id, pop) |> 
  mutate(
    rtrn_mu_cml = slide_dbl(rtrn, mean, .before = Inf),
    lm_fit = slide(
      .x = cur_data(), #the subset of rows
      .f = ~lm(rtrn ~ year, data = .x), #the thing to do to them
      .before = Inf, #how far back to look
      .complete = T
    ),
    lm_pred = lm_fit |> 
      map_dbl(~if_else(is.null(.x), NA_real_, last(.x$fitted.values)))
  ) |> 
  ungroup()

foo |> 
  select(-lm_fit) |> 
  filter(pop_id > 30) |> #reduce for plotting 
  pivot_longer(cols = -c(year, pop_id, pop), names_to = "var", values_to = "val") |> 
  {\(x) 
  ggplot(x, aes(year, val, color = var)) +
  geom_line(data = filter(x, var != "rtrn")) +
  geom_point(data = filter(x, var == "rtrn")) + 
  scale_x_continuous(n.breaks = 10,  guide = guide_axis(n.dodge = 2)) +
  facet_wrap(~pop_id, scales = "free", ncol = 1)
  }()
```

```{r one_ahead_controls}
#now fairly trivial to build list of stan data lists
one_ahead_year_min <- 1998
one_ahead_years_max <- 2015:2017

set_names(one_ahead_years_max) |> 
  map(~tbl_coho_filter_to_stan(full = tbl_coho, year_min = one_ahead_year_min, year_max = .x)) |> 
  map_df(
    ~.x |> #each yearmax list of stan datasets
      map(~.x |> #each stan dataset (smolt, esc, catch, MS, rtrn)
            summarise(
              n = n(), ymin = min(year), ymax = max(year),
              ymin = min(yr), ymax = max(yr))))
```

```{r one_ahead_stipm}
#various stan warnings get hidden within map

#this is very memory greedy - 3 years at 200iter/2chains is 150MB with Rstudio holding 1.3GB
#also ~5min/chain per year? something like 5-10m per year, again at 200/2

one_ahead_stipm <- set_names(one_ahead_years_max) |> 
  map(
    function(ymax){
      stan_data <- tbl_coho_filter_to_stan(full = tbl_coho, year_min = one_ahead_year_min, year_max = ymax)

      stan_fit <- stan(
        file = 'LD_coho_forecast_6_2_4.stan', 
        iter = 200, chains = 2, thin = 1, seed = 222,
        control = list(adapt_delta = 0.99, max_treedepth = 10.25),
        data = list(
          n_year = length(one_ahead_year_min:ymax), 
          n_pop = length(unique(tbl_coho$pop_id)),
          u = matrix(1, nrow = 1, ncol = length(unique(tbl_coho$pop_id))),
          dist = units::drop_units(sf::st_distance(sf_coord)/10000), #values are identical
          
          pop_smolt = unique(stan_data$smolt$pop_id), #pop_ids with smolt data 
          n_pop_smolt = length(unique(stan_data$smolt$pop_id)),
          smolt_true = stan_data$smolt$yr,
          smolt_dat = stan_data$smolt$`Smolt Abundance`,
          n_smolt = nrow(stan_data$smolt),
          
          pop_esc = unique(stan_data$esc$pop_id),  # pop_ids with escapement data
          n_pop_esc = length(unique(stan_data$esc$pop_id)),
          esc_true = stan_data$esc$yr,
          esc_dat = stan_data$esc$spwn,
          n_esc = nrow(stan_data$esc),
          
          pop_catch = unique(stan_data$catch$pop_id), #pop_ids with harvest data
          n_pop_catch = length(unique(stan_data$catch$pop_id)),
          harvest_true = stan_data$catch$yr,
          harvest_dat = stan_data$catch$hvst,
          n_harvest = nrow(stan_data$catch),
          
          pop_MS = unique(stan_data$MS$pop_id), #pop_ids with marine survival data
          n_pop_MS = length(unique(stan_data$MS$pop_id)),
          MS_true = stan_data$MS$yr, #orig uses Fishery_Plus_Escapement rather than Release_No to filter...
          MS_dat_x = stan_data$MS$Fishery_Plus_Escapement |> round(), #stan expects integer...
          MS_dat_N = stan_data$MS$Release_No,
          n_MS = nrow(stan_data$MS),
          
          stream_dist = tbl_coho |> group_by(pop) |> summarise(d = mean(KM, na.rm = T), .groups = "drop") |> select(d) |> unlist() |> as.numeric(),
          
          sigma_esc = 0.2,
          
          n_hatchery = filter(tbl_coho, hat == 1) |> distinct(pop_id) |> nrow(),
          hatchery = distinct(stan_data$MS, pop_id, pop, hat) |> 
            mutate(hat_id = if_else(hat > 0, row_number(), NA_integer_)) |> 
            filter(!is.na(hat_id)) |> pluck("hat_id"),
          wild = distinct(stan_data$MS, pop_id, pop, hat) |> 
            mutate(hat_id = if_else(hat < 1, row_number(), NA_integer_)) |> 
            filter(!is.na(hat_id)) |> pluck("hat_id"), 
          
          slice_smolt_start = stan_data$smolt |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
          slice_smolt_end = stan_data$smolt |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
          
          slice_esc_start = stan_data$esc |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
          slice_esc_end = stan_data$esc |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
          
          slice_harvest_start = stan_data$catch |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
          slice_harvest_end = stan_data$catch |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid"),
          
          slice_MS_start = stan_data$MS |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
          slice_MS_end = stan_data$MS |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid")
        )
      )
      return(stan_fit)
    }
  )

str(one_ahead_stipm, max.level = 1)

```

```{r one_ahead_ar1}
#various stan warnings get hidden within map
one_ahead_ar1 <- set_names(one_ahead_years_max) |> 
  map(
    function(ymax){
      stan_data <- tbl_coho_filter_to_stan(full = tbl_coho, year_min = one_ahead_year_min, year_max = ymax)
      #return(stan_data)
      
      stan_fit <- stan(
        file = 'LD_coho_forecast_AR_ind_2.stan',
        iter = 200, chains = 2, thin = 1, seed = 222,
        control = list(adapt_delta = 0.99, max_treedepth = 10.25),
        data = list(
          #Number of years (total, includes several missing years for some stocks)
          n_year = length(one_ahead_year_min:ymax) + 1,
          #Number of total populations
          n_pop = length(unique(tbl_coho$pop_id)),
          #Number of populations with return data
          n_pop_tot = length(unique(stan_data$rtrn$pop_id)),
          #Which populations possess return data
          pop_tot = unique(stan_data$rtrn$pop_id),
          #Length of the return data vectors
          n_tot = nrow(stan_data$rtrn), #length(tot_dat)
          #Vectors of all return data across all populations
          tot_dat = stan_data$rtrn$rtrn,
          #Vectors of the indices identifying which years are those with non-NA data for the return data
          tot_true = stan_data$rtrn$yr,
          #Paired vectors of slice points indicating the beginning, and end of the data for a particular population
          slice_tot_start = stan_data$rtrn |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
          slice_tot_end = stan_data$rtrn |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid")
        )
      )
      return(stan_fit)
    }
  )

str(one_ahead_ar1, max.level = 1)

```

```{r first_look_repeat_fits}
#currently ~10s per year...
#can/should reduce function to only adult_est?

one_ahead_stipm_smry <- map(.x = one_ahead_stipm, .f = fit_smry, year_min = one_ahead_year_min)

names(one_ahead_stipm_smry) |> 
  map_df(
    ~one_ahead_stipm_smry[[.x]]$adult_est |> 
      filter(pop_id == 36) |> 
      mutate(year_max = .x) |> 
      select(year_max, year, `10%`:`90%`, pop_id, pop) 
  ) |> 
  ggplot(aes(x = year, y = `50%`, ymin = `10%`, ymax = `90%`, color = year_max, fill = year_max)) +
  scale_y_continuous("Estimated adult return", labels = scales::comma) +
  scale_fill_brewer(type = "qual", aesthetics = c("fill", "color") ) +
  geom_ribbon(alpha = 0.2) + geom_line() +
  geom_point(
    data = tbl_coho_stan$esc |> filter(pop_id == 36, year >= one_ahead_year_min) |> select(year, spwn),
    aes(year, spwn),
    inherit.aes = F) +
  facet_wrap(~pop)



one_ahead_ar1_smry <- map(.x = one_ahead_ar1, .f = fit_smry, year_min = one_ahead_year_min)

names(one_ahead_ar1_smry) |> 
  map_df(
    ~one_ahead_ar1_smry[[.x]]$adult_est |> 
      filter(pop_id == 36) |> 
      mutate(year_max = .x) |> 
      select(year_max, year, `10%`:`90%`, pop_id, pop) 
  ) |> 
  ggplot(aes(x = year, y = `50%`, ymin = `10%`, ymax = `90%`, color = year_max, fill = year_max)) +
  scale_y_continuous("Estimated adult return", labels = scales::comma) +
  scale_fill_brewer(type = "qual", aesthetics = c("fill", "color") ) +
  geom_ribbon(alpha = 0.2) + geom_line() +
  geom_point(
    data = tbl_coho_stan$rtrn |> filter(pop_id == 36, year >= one_ahead_year_min) |> select(year, rtrn),
    aes(year, rtrn),
    inherit.aes = F) +
  facet_wrap(~pop)


#ar1 written so data through 2017 generates a 2018 in adult_est
one_ahead_ar1_smry$`2017`$adult_est |> tail()
#but stipm through 2017 ends adult_est with 2017
one_ahead_stipm_smry$`2017`$adult_est |> tail()
#and perhaps adds 2018 in adult_pred
one_ahead_stipm_smry$`2015`$adult_pred |> tail()

```

```{r test_2050s}
#further into future just with larger n_year? oh yes.

fit_ar1_test <- stan(
  file = 'LD_coho_forecast_AR_ind_2.stan',
  iter = 200, chains = 2, thin = 1, seed = 222,
  control = list(adapt_delta = 0.99, max_treedepth = 10.25),
  data = list(
    #Number of years (total, includes several missing years for some stocks)
    n_year = length(unique(tbl_coho$year))*2,
    #Number of total populations    
    n_pop = length(unique(tbl_coho$pop_id)),
    #Number of populations with return data
    n_pop_tot = length(unique(tbl_coho_stan$rtrn$pop_id)),
    #Which populations possess return data
    pop_tot = unique(tbl_coho_stan$rtrn$pop_id),
    #Length of the return data vectors
    n_tot = nrow(tbl_coho_stan$rtrn), #length(tot_dat)
    #Vectors of all return data across all populations
    tot_dat = tbl_coho_stan$rtrn$rtrn,
    #Vectors of the indices identifying which years are those with non-NA data for the return data
    tot_true = tbl_coho_stan$rtrn$yr,
    #Paired vectors of slice points indicating the beginning, and end of the data for a particular population
    slice_tot_start = tbl_coho_stan$rtrn |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = min(rowid), .groups = "drop") |> pluck("rowid"),
    slice_tot_end = tbl_coho_stan$rtrn |> rowid_to_column() |> group_by(pop_id) |> summarise(rowid = max(rowid), .groups = "drop") |> pluck("rowid")
    )
  )

fit_ar1_test_smry <- fit_smry(fit_ar1_test)

fit_ar1_test_smry$adult_est |> #tail() 
  filter(pop_id > 30) |> 
  ggplot(aes(x = year)) +
  scale_y_continuous("Estimated adult return", labels = scales::comma) +
  scale_fill_brewer(type = "qual", aesthetics = c("fill", "color") ) +
  geom_ribbon(aes(ymin = `10%`, ymax = `90%`), alpha = 0.2) + 
  geom_line(aes(y = `50%`)) +
  geom_point(
    data = tbl_coho_stan$rtrn |> filter(pop_id > 30) |> select(year, pop, pop_id, rtrn),
    aes(y = rtrn),
    inherit.aes = T) +
  facet_wrap(~pop)

```

# diagnostics and results


